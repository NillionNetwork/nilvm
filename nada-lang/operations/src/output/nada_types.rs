use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::Path,
};

use anyhow::Result;

use crate::types::{
    BuiltOperations, BuiltUnaryOperation, ClassMethod, DataType, InstanceMethod, Literal, OperationMetadata,
    PythonShape,
};

/// A list of symbols. It can be joined into a string representation.
#[derive(Default)]
struct Symbols(BTreeSet<String>);

impl Symbols {
    fn from_vec(vec: Vec<String>) -> Self {
        Self(vec.into_iter().collect::<BTreeSet<_>>())
    }

    fn join(self, separator: &str, quoted: bool) -> String {
        let mut items = self.0.into_iter().collect::<Vec<_>>();

        if quoted {
            items = items.into_iter().map(|item| format!("\"{item}\"")).collect();
        }

        items.join(separator)
    }
}

/// Generates Python operators for all types.
#[derive(Default)]
struct PythonGenerator {
    /// Python imports.
    imports: BTreeMap<String, Symbols>,

    /// Main contents: classes and functions.
    contents: String,

    /// Current indentation.
    indent: usize,
}

impl PythonGenerator {
    /// Writes the contents to a file.
    fn render(self, filepath: &Path) -> Result<()> {
        let mut contents = String::default();

        // Generated file warning.
        contents.push_str("# This file is automatically generated. Do not edit!\n");

        contents.push('\n');

        // Imports.
        for (module, symbols) in self.imports {
            let symbols = symbols.join(", ", false);
            contents.push_str(&format!("from {module} import {symbols}"));
            contents.push('\n');
        }

        contents.push('\n');

        // Main contents.
        contents.push_str(&self.contents);

        fs::write(filepath, contents)?;

        Ok(())
    }

    /// Writes text.
    /// Note: no new line is added, no indentation is prepended.
    fn write_text(&mut self, text: &str) {
        self.contents.push_str(text);
    }

    /// Writes the current indentation level using 4 spaces for each.
    fn write_ident(&mut self) {
        for _ in 0..self.indent {
            self.contents.push_str("    ");
        }
    }

    /// Builds a line using a closure.
    fn build_line<F>(&mut self, line: F)
    where
        F: FnOnce(&mut Self),
    {
        self.write_ident();
        line(self);
        self.line();
    }

    /// Writes text, prepending the current indentation and appending a new line character.
    fn write_line(&mut self, content: &str) {
        self.build_line(|g| {
            g.write_text(content);
        });
    }

    /// Appends a new line character.
    fn line(&mut self) {
        self.contents.push('\n');
    }

    /// Builds an indented block using a closure.
    fn build_block<F>(&mut self, block: F)
    where
        F: FnOnce(&mut Self),
    {
        self.indent += 1;

        block(self);

        self.indent -= 1;
    }

    /// Adds a Python import. Duplicates are ignored.
    fn add_import(&mut self, module: &str, symbol: &str) {
        self.imports
            .entry(module.to_string())
            .and_modify(|symbols| _ = symbols.0.insert(symbol.to_string()))
            .or_insert(Symbols::from_vec(vec![symbol.to_string()]));
    }
}

fn generate_class_header(data_type: &DataType, g: &mut PythonGenerator) -> Result<()> {
    g.add_import("dataclasses", "dataclass");
    g.add_import(".", "NadaType");

    let name = data_type.name();
    g.write_line("@dataclass");
    g.write_line(&format!("class {name}(NadaType):"));

    g.build_block(|g| {
        // Literals need to store a value.
        if matches!(data_type, DataType::Literal(_)) {
            g.add_import("nada_dsl.circuit_io", "Literal");

            let python_type = data_type.python_type();

            g.write_line(&format!("value: {python_type}"));
            g.line();

            g.write_line(&format!("def __init__(self, value: {python_type}):"));

            g.build_block(|g| {
                g.write_line("super().__init__(inner=Literal(value=value, source_ref=SourceRef.back_frame()))");
                g.write_line(&format!("if isinstance(value, {python_type}):"));

                g.build_block(|g| {
                    g.write_line("self.value = value");
                });

                g.write_line("else:");

                g.build_block(|g| {
                    g.write_line(&format!(
                        "raise ValueError(f\"Expected {python_type}, got {{type(value).__name__}}\")"
                    ));
                });
            });
            g.line();
        } else {
            g.write_line("def __init__(self, inner: NadaType):");
            g.build_block(|g| g.write_line("super().__init__(inner)"));
        }
    });

    Ok(())
}

/// Generates "if isinstance" checks for operators.
fn generate_instance_check(
    right_input: &DataType,
    output: &DataType,
    is_first: bool,
    operation: &OperationMetadata,
    g: &mut PythonGenerator,
) {
    let right_input_name = right_input.name();

    g.build_line(|g| {
        if is_first {
            g.write_text(&format!("if isinstance(other, {right_input_name})"));
        } else {
            g.write_text(&format!("elif isinstance(other, {right_input_name})"));
        }

        g.write_text(":");
    });

    g.build_block(|g| {
        let output_name = output.name();

        // If the output is a literal we can perform the operation here.
        if matches!(output, DataType::Literal(_)) {
            let python_type = output.python_type();

            match &operation.python_shape {
                PythonShape::BinaryOperator { symbol, .. } => {
                    g.write_line(&format!("return {output_name}(value={python_type}(self.value {symbol} other.value))"))
                }
                PythonShape::InstanceMethod { name } => {
                    g.write_line(&format!("return {output_name}(value={python_type}(self.value.{name}(other.value)))"))
                }
            }
        } else {
            let operation_name = &operation.name;

            g.add_import("nada_dsl.operations", operation_name);
            g.add_import("nada_dsl.source_ref", "SourceRef");

            g.write_line(&format!(
                "operation = {operation_name}(left=self, right=other, source_ref=SourceRef.back_frame())"
            ));

            g.build_line(|g| {
                g.write_text(&format!("return {output_name}(inner=operation"));

                g.write_text(")");
            });
        }
    });
}

/// Generates "if isinstance" checks for operators.
fn generate_instance_check_for_methods(
    arg_types: &[DataType],
    output_type: Option<DataType>,
    method_field_names: &[String],
    is_first_set_of_args: bool,
    operation_name: &str,
    g: &mut PythonGenerator,
) {
    // If there are no arguments, there is nothing to check.
    if !arg_types.is_empty() {
        g.build_line(|g| {
            let mut is_first_argument = true;
            for (arg_count, arg_type) in arg_types.iter().enumerate() {
                let arg = arg_type.name();
                if is_first_set_of_args && is_first_argument {
                    g.write_text(&format!("if isinstance(arg_{arg_count}, {arg})"));
                } else if is_first_argument {
                    g.write_text(&format!("elif isinstance(arg_{arg_count}, {arg})"));
                } else {
                    g.write_text(&format!(" and isinstance(arg_{arg_count}, {arg})"));
                }

                if is_first_argument {
                    is_first_argument = false;
                }
            }

            g.write_text(":");
        });
    }

    fn call_operation(
        g: &mut PythonGenerator,
        arg_types: &[DataType],
        method_field_names: &[String],
        output_type: Option<DataType>,
        operation_name: &str,
    ) {
        match output_type {
            Some(output) => {
                let output_name = output.name();
                if matches!(output, DataType::Literal(_)) {
                    let python_type = output.python_type();

                    g.write_line(&format!(
                        "return {output_name}(value={python_type}(self.value.{operation_name}(other.value)))"
                    ))
                } else {
                    g.add_import("nada_dsl.operations", operation_name);
                    g.add_import("nada_dsl.source_ref", "SourceRef");

                    g.build_line(|g| {
                        match method_field_names.first() {
                            Some(arg_0) => {
                                g.write_text(&format!("operation = {operation_name}({arg_0}=self"));
                                for (arg_count, arg_name) in method_field_names.iter().skip(1).enumerate() {
                                    g.write_text(&format!(", {arg_name}=arg_{arg_count}"));
                                }
                            }
                            None => {
                                g.write_text(&format!("operation = {operation_name}(this=self"));
                                for (arg_count, _arg_type) in arg_types.iter().enumerate() {
                                    g.write_text(&format!(", arg_{arg_count}=arg_{arg_count}"));
                                }
                            }
                        }
                        g.write_text(", source_ref=SourceRef.back_frame())");
                    });

                    g.build_line(|g| {
                        g.write_text(&format!("return {output_name}(inner=operation"));

                        g.write_text(")");
                    });
                }
            }
            None => g.write_line("return"),
        }
    }

    if !arg_types.is_empty() {
        g.build_block(|g| call_operation(g, arg_types, method_field_names, output_type, operation_name));
    } else {
        call_operation(g, arg_types, method_field_names, output_type, operation_name);
    }
}

fn generate_type_list(types: Symbols, g: &mut PythonGenerator) -> String {
    if types.0.is_empty() {
        panic!("unexpected empty type list");
    }

    let type_len = types.0.len();
    let types_string = types.join(", ", true);

    if type_len > 1 {
        g.add_import("typing", "Union");

        format!("Union[{types_string}]")
    } else {
        types_string
    }
}

/// Generates a unary operation, no instance checks because it's not needed.
fn generate_unary_operation(
    data_type: &DataType,
    unary_operation: &BuiltUnaryOperation,
    g: &mut PythonGenerator,
) -> anyhow::Result<()> {
    let input_outputs = unary_operation
        .allowed_combinations
        .iter()
        .filter(|(input, _)| *input == data_type)
        .collect::<Vec<(&DataType, &DataType)>>();

    let (inputs, outputs): (Vec<_>, Vec<_>) = input_outputs
        .clone()
        .into_iter()
        .map(|(input, output)| (input.name().to_string(), output.name().to_string()))
        .unzip();

    g.build_block(|g| {
        match &unary_operation.metadata.python_shape {
            PythonShape::BinaryOperator { name, .. } => g.write_line(&format!("def __{name}__(")),
            PythonShape::InstanceMethod { name } => g.write_line(&format!("def {name}(")),
        }
        g.build_block(|g| {
            let types = Symbols::from_vec(inputs);
            let types = generate_type_list(types, g);
            g.build_line(|g| {
                g.write_text(&format!("self: {types}"));
            });
        });

        let types = generate_type_list(Symbols::from_vec(outputs), g);
        g.build_line(|g| {
            g.write_text(&format!(") -> {types}"));
            g.write_text(":");
        });

        g.build_block(|g| {
            let operation_name = &unary_operation.metadata.name;
            for (input, output) in input_outputs.iter() {
                let python_type = output.python_type();
                let output_name = output.name();
                g.add_import("nada_dsl.operations", operation_name);
                g.add_import("nada_dsl.source_ref", "SourceRef");

                if matches!(input, DataType::Literal(_)) {
                    match &unary_operation.metadata.python_shape {
                        PythonShape::BinaryOperator { symbol, .. } => {
                            // Workaround for the special case of `not` and literals.
                            if operation_name == "Not" {
                                g.write_line(&format!("return {output_name}(value={python_type}(not self.value))"))
                            } else {
                                g.write_line(&format!("return {output_name}(value={python_type}({symbol}self.value))"))
                            }
                        }
                        PythonShape::InstanceMethod { name } => {
                            g.write_line(&format!("return {output_name}(value={python_type}(self.value.{name}()))"))
                        }
                    }
                } else {
                    g.write_line(&format!(
                        "operation = {operation_name}(this=self, source_ref=SourceRef.back_frame())"
                    ));

                    g.build_line(|g| {
                        g.write_text(&format!("return {output_name}(inner=operation"));

                        g.write_text(")");
                    });
                }
            }
        });
        g.line();
    });

    Ok(())
}

fn generate_binary_operation(
    operation: &OperationMetadata,
    operators: &[((DataType, DataType), DataType)],
    g: &mut PythonGenerator,
) -> Result<()> {
    let (inputs, outputs): (Vec<_>, Vec<_>) = operators
        .iter()
        .map(|((_, right_input), output)| (right_input.name().to_string(), output.name().to_string()))
        .unzip();

    g.build_block(|g| {
        match &operation.python_shape {
            PythonShape::BinaryOperator { name, .. } => g.write_line(&format!("def __{name}__(")),
            PythonShape::InstanceMethod { name } => g.write_line(&format!("def {name}(")),
        }

        g.build_block(|g| {
            let types = Symbols::from_vec(inputs);
            let types = generate_type_list(types, g);
            g.build_line(|g| {
                g.write_text(&format!("self, other: {types}"));
            });
        });

        let types = generate_type_list(Symbols::from_vec(outputs), g);
        g.build_line(|g| {
            g.write_text(&format!(") -> {types}"));
            g.write_text(":");
        });

        g.build_block(|g| {
            let mut first = true;
            for ((_left_input, right_input), output) in operators.iter() {
                generate_instance_check(right_input, output, first, operation, g);
                if first {
                    first = false;
                }
            }

            g.write_line("else:");
            g.build_block(|g| match &operation.python_shape {
                PythonShape::BinaryOperator { symbol, .. } => {
                    g.write_line(&format!("raise TypeError(f\"Invalid operation: {{self}} {symbol} {{other}}\")"))
                }
                PythonShape::InstanceMethod { name } => {
                    g.write_line(&format!("raise TypeError(f\"Invalid operation: {{self}}.{name}({{other}})\")"))
                }
            });
        });
        g.line();
    });

    Ok(())
}

/// Generate the body of a class method.
///
/// NOTE: Currently we contemplate only class methods with no arguments
fn generate_class_method(
    class_method: &ClassMethod,
    data_type: &DataType,
    g: &mut PythonGenerator,
) -> anyhow::Result<()> {
    let method_name = class_method.method_name();
    let operation_name = class_method.operation_name();
    let data_type_name = data_type.name();

    g.add_import("nada_dsl.operations", operation_name);
    g.build_block(|g| {
        g.write_line("@classmethod");
        g.write_line(&format!("def {method_name}(cls) -> \"{data_type_name}\":"));
        g.build_block(|g| {
            g.write_line(&format!("return {data_type_name}(inner={operation_name}(source_ref=SourceRef.back_frame()))"))
        });
        g.write_line("")
    });
    Ok(())
}

/// Generate the body of an instance method.
fn generate_instance_method(
    class: &DataType,
    instance_method: &InstanceMethod,
    g: &mut PythonGenerator,
) -> anyhow::Result<()> {
    let operators = instance_method
        .get_variants()
        .iter()
        .filter(|(class_type, _)| *class_type == class)
        .flat_map(|(_, vecs_of_args)| {
            vecs_of_args
                .get_parameter_types()
                .iter()
                .map(|vec_of_args| (vec_of_args.0.clone(), vec_of_args.1))
                .collect::<Vec<_>>()
        })
        .collect::<Vec<_>>();
    // Flatten the list of types to get the Union.
    let args_types_flat =
        operators.iter().flat_map(|(args, _)| args.iter().map(|dt| dt.name()).collect::<Vec<_>>()).collect::<Vec<_>>();
    let output_types_flat =
        operators.iter().map(|(_, output)| output.map(|o| o.name()).unwrap_or_else(String::new)).collect::<Vec<_>>();
    let method_field_names = instance_method.method_field_names();
    if !method_field_names.is_empty() && method_field_names.len() != instance_method.get_num_args() + 1 {
        panic!(
            "{}: Mismatch between argument names ({}) and actual number of arguments ({})",
            instance_method.method_name(),
            method_field_names.len(),
            instance_method.get_num_args()
        );
    }

    g.add_import("nada_dsl.operations", instance_method.operation_name());
    g.build_block(|g| {
        let method_name = instance_method.method_name();
        g.write_line(&format!("def {method_name}("));

        g.build_block(|g| {
            let class_string = generate_type_list(Symbols::from_vec(vec![class.name().to_string()]), g);
            g.build_line(|g| {
                g.write_text(&format!("self: {class_string},"));
            });

            // If there are arguments other than "self".
            if !args_types_flat.is_empty() {
                let args_types = generate_type_list(Symbols::from_vec(args_types_flat.clone()), g);
                g.build_line(|g| {
                    if instance_method.get_num_args() > 0 {
                        g.write_text("arg_0");
                    }
                    for arg in 1..instance_method.get_num_args() {
                        g.write_text(&format!(", arg_{arg}"));
                    }
                    g.write_text(&format!(": {args_types}"));
                });
            }
        });

        if !output_types_flat.is_empty() {
            let output_types = generate_type_list(Symbols::from_vec(output_types_flat), g);
            g.build_line(|g| {
                g.write_text(&format!(") -> {output_types}"));
                g.write_text(":");
            });
        } else {
            g.write_line("):");
        }

        g.build_block(|g| {
            let mut first = true;

            for (_self_type, all_args_and_outputs) in instance_method
                .get_variants()
                .iter() // For indentation.
                .filter(|(class_type, _)| *class_type == class)
            {
                for (inputs, output) in all_args_and_outputs.get_parameter_types().iter() {
                    generate_instance_check_for_methods(
                        inputs,
                        *output,
                        method_field_names,
                        first,
                        instance_method.operation_name(),
                        g,
                    );
                    if first {
                        first = false;
                    }
                }
            }

            if !args_types_flat.is_empty() {
                g.write_line("else:");
                g.build_block(|g| {
                    g.build_line(|g| {
                        let operation_name = instance_method.operation_name();
                        g.write_text(&format!("raise TypeError(f\"Invalid operation: {{self}}.{operation_name}("));
                        if instance_method.get_num_args() > 0 {
                            g.write_text("{arg_0}");
                        }
                        for arg in 1..instance_method.get_num_args() {
                            g.write_text(&format!(", {{arg_{arg}}}"));
                        }
                        g.write_text(")\")")
                    });
                });
            }
        });
        g.write_line("")
    });
    Ok(())
}

/// Generates the boolean evaluation in Python of public compilation time literals.
fn generate_boolean_evaluation(data_type: &DataType, g: &mut PythonGenerator) {
    if let DataType::Literal(literal) = data_type {
        if literal == &Literal::Boolean {
            g.build_block(|g| {
                g.write_line("def __bool__(self) -> bool:");
                g.build_block(|g| {
                    g.write_line("return self.value");
                });
            });
            g.line();
        }
    }
}

/// Generates Nada types in a directory.
pub fn generate_types(built_ops: &BuiltOperations, path: &Path) -> anyhow::Result<()> {
    let mut g = PythonGenerator::default();

    // Loop for each data type, and all operations per type
    for (data_type, operations_by_name) in built_ops.operations_by_type.iter() {
        generate_class_header(data_type, &mut g)?;

        let mut empty_class = true;

        generate_boolean_evaluation(data_type, &mut g);
        for (_operation_name, operations) in operations_by_name.iter() {
            if !operations.0.is_empty() {
                empty_class = false;
                let (operators, metadata, _type) = operations;
                generate_binary_operation(metadata, operators, &mut g)?;
            }
        }

        if let Some(unary_operations) = built_ops.unary_operations.get(data_type) {
            for unary_operation in unary_operations {
                generate_unary_operation(data_type, unary_operation, &mut g)?;
            }
        }
        if let Some(class_methods) = built_ops.class_methods.get(data_type) {
            for class_method in class_methods {
                generate_class_method(class_method, data_type, &mut g)?;
            }
        }
        if let Some(methods) = built_ops.instance_methods.get(data_type) {
            for instance_method in methods {
                generate_instance_method(data_type, instance_method, &mut g)?;
            }
        }

        if empty_class {
            g.build_block(|g| {
                g.write_line("pass");
            });
        }
    }

    g.render(&path.join("types.py"))?;

    Ok(())
}
