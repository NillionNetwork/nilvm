//! The threshold public key implementation.

use crate::privatekey::ThresholdPrivateKey;

use generic_ec::{errors::InvalidPoint, Curve, NonZero, Point};
use std::ops::Mul;
use thiserror::Error;

#[cfg(feature = "serde")]
use serde_with::serde_as;

/// ThresholdPublicKey represents an elliptic curve public key used for DSA signatures
#[derive(Debug, PartialEq, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ThresholdPublicKey<E: Curve>(NonZero<Point<E>>);

impl<E: Curve> ThresholdPublicKey<E> {
    /// Compute a [`ThresholdPublicKey`] from a private [`ThresholdPrivateKey`] value.
    ///
    /// # Arguments
    ///
    /// * `private_key` - Reference to the [`ThresholdPrivateKey`] from which the public key is derived.
    ///
    /// The public key is generated by multiplying the elliptic curve generator by the private key scalar value.
    ///
    /// # Returns
    ///
    /// * A new [`ThresholdPublicKey`] that corresponds to the provided private key.
    ///
    /// # Example
    ///
    /// ```
    /// use generic_ec::Curve;
    /// use generic_ec::SecretScalar;
    /// use generic_ec::curves::{Secp256k1,Ed25519};
    /// use threshold_keypair::privatekey::ThresholdPrivateKey;
    /// use threshold_keypair::publickey::ThresholdPublicKey;
    /// use rand::rngs::OsRng;
    ///
    /// let mut csprng = OsRng;
    /// let sk = ThresholdPrivateKey::from_scalar(SecretScalar::<Secp256k1>::random(&mut csprng)).unwrap();
    /// let pk = ThresholdPublicKey::from_private_key(&sk);
    ///
    /// assert_eq!(pk.as_point().is_zero(), false);
    ///
    /// let sk = ThresholdPrivateKey::from_scalar(SecretScalar::<Ed25519>::random(&mut csprng)).unwrap();
    /// let pk = ThresholdPublicKey::from_private_key(&sk);
    ///
    /// assert_eq!(pk.as_point().is_zero(), false);
    /// ```
    pub fn from_private_key(private_key: &ThresholdPrivateKey<E>) -> Self {
        // pk = generator * sk
        let pk: NonZero<Point<E>> = Point::<E>::generator().to_nonzero_point().mul(private_key.as_non_zero_scalar());
        Self(pk)
    }

    /// Convert a [`Point`] into a [`ThresholdPublicKey`].
    ///
    /// # Arguments
    ///
    /// * `point` - A [`Point`] on the elliptic curve.
    ///
    /// Attempts to convert the provided point into a valid non-zero point to be used as the public key.
    /// Returns an error if the point is invalid or the identity point.
    ///
    /// # Returns
    ///
    /// * A result with a new [`ThresholdPublicKey`] or an error.
    ///
    /// # Errors
    ///
    /// * [`ThresholdPublicKeyError::ZeroPoint`] if the point is the identity point.
    ///
    /// # Example
    ///
    /// ```
    /// use generic_ec::Curve;
    /// use generic_ec::Point;
    /// use generic_ec::curves::{Secp256k1,Ed25519};
    /// use threshold_keypair::publickey::ThresholdPublicKey;
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Secp256k1>::from_point(point);
    ///
    /// assert!(pk.is_ok());
    ///
    /// let point = Point::<Ed25519>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Ed25519>::from_point(point);
    ///
    /// assert!(pk.is_ok());
    /// ```
    pub fn from_point(point: Point<E>) -> Result<Self, ThresholdPublicKeyError> {
        NonZero::from_point(point).map(Self).ok_or(ThresholdPublicKeyError::ZeroPoint)
    }

    /// Borrow the inner [`Point`] from this [`ThresholdPublicKey`].
    ///
    /// In elliptic curve cryptography, public keys are represented by points on the elliptic curve.
    ///
    /// # Returns
    ///
    /// * A reference to the inner [`Point`] representing the public key.
    ///
    /// # Example
    ///
    /// ```
    /// use threshold_keypair::publickey::ThresholdPublicKey;
    /// use generic_ec::Point;
    /// use generic_ec::Curve;
    /// use generic_ec::curves::{Secp256k1,Ed25519};
    /// use rand::rngs::OsRng;
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Secp256k1>::from_point(point).unwrap();
    ///
    /// assert!(!pk.as_point().is_zero());
    ///
    /// let point = Point::<Ed25519>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Ed25519>::from_point(point).unwrap();
    ///
    /// assert!(!pk.as_point().is_zero());
    /// ```
    pub fn as_point(&self) -> &Point<E> {
        &self.0
    }

    /// Decode an elliptic curve point (compressed or uncompressed) from the `Elliptic-Curve-Point-to-Octet-String` encoding,
    /// as described in SEC 1: Elliptic Curve Cryptography (Version 2.0), section 2.3.3., <http://www.secg.org/sec1-v2.pdf>.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A byte array or reference to a byte array that contains the encoded elliptic curve point.
    ///
    /// # Returns
    ///
    /// * A result with a new [`ThresholdPublicKey`] or an error.
    ///
    /// # Errors
    ///
    /// * [`ThresholdPublicKeyError::InvalidPoint`] if the point fails to decode properly.
    ///
    /// # Example
    ///
    /// ```
    /// use threshold_keypair::publickey::ThresholdPublicKey;
    /// use generic_ec::Curve;
    /// use generic_ec::Point;
    /// use generic_ec::curves::{Secp256k1,Ed25519};
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Secp256k1>::from_point(point).unwrap();
    /// let bytes = pk.to_bytes(false);
    ///
    /// let decoded_pk = ThresholdPublicKey::<Secp256k1>::from_bytes(bytes);
    /// assert!(decoded_pk.is_ok());
    ///
    /// let point = Point::<Ed25519>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Ed25519>::from_point(point).unwrap();
    /// let bytes = pk.to_bytes(false);
    ///
    /// let decoded_pk = ThresholdPublicKey::<Ed25519>::from_bytes(bytes);
    /// assert!(decoded_pk.is_ok());
    /// ```
    pub fn from_bytes(bytes: impl AsRef<[u8]>) -> Result<Self, ThresholdPublicKeyError> {
        let point = Point::from_bytes(bytes)?;
        ThresholdPublicKey::<E>::from_point(point)
    }

    /// Encode the elliptic curve public key point into a byte array.
    ///
    /// # Arguments
    ///
    /// * `compressed` - A boolean indicating whether to compress the point or not.
    ///
    /// # Returns
    ///
    /// * A `Vec<u8>` containing the encoded elliptic curve point.
    ///
    /// # Example
    ///
    /// ```
    /// use generic_ec::Curve;
    /// use generic_ec::Point;
    /// use generic_ec::curves::{Secp256k1,Ed25519};
    /// use threshold_keypair::publickey::ThresholdPublicKey;
    /// use threshold_keypair::{COMPRESSED_ECDSA_PUBLIC_KEY_LENGTH,
    ///     UNCOMPRESSED_ECDSA_PUBLIC_KEY_LENGTH,
    ///     EDDSA_PUBLIC_KEY_LENGTH};
    ///
    /// let point = Point::<Ed25519>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Ed25519>::from_point(point).unwrap();
    ///
    /// let encoded = pk.clone().to_bytes(true);
    /// assert_eq!(encoded.len(), EDDSA_PUBLIC_KEY_LENGTH);
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = ThresholdPublicKey::<Secp256k1>::from_point(point).unwrap();
    ///
    /// let comp_encoded = pk.clone().to_bytes(true);
    /// assert_eq!(comp_encoded.len(), COMPRESSED_ECDSA_PUBLIC_KEY_LENGTH);
    ///
    /// let uncomp_encoded = pk.to_bytes(false);
    /// assert_eq!(uncomp_encoded.len(), UNCOMPRESSED_ECDSA_PUBLIC_KEY_LENGTH);
    /// ```
    pub fn to_bytes(self, compressed: bool) -> Vec<u8> {
        self.0.to_bytes(compressed).to_vec()
    }
}

/// Represents errors that can occur when working with an [`ThresholdPublicKey`].
#[derive(Error, Debug)]
pub enum ThresholdPublicKeyError {
    /// Error when the point provided is invalid or cannot be interpreted as a valid elliptic curve point.
    #[error("Invalid point for public key")]
    InvalidPointError(InvalidPoint),
    /// Error when the identity point is used to create an [`ThresholdPublicKey`].
    #[error("Identity point used to create ecdsa public key")]
    ZeroPoint,
}

// Implement the From trait to convert InvalidPoint into ThresholdPublicKeyError
impl From<InvalidPoint> for ThresholdPublicKeyError {
    fn from(error: InvalidPoint) -> Self {
        ThresholdPublicKeyError::InvalidPointError(error)
    }
}

/// EcdsaPublicKeyArray is a 33-byte array representing the public key in compressed format.
/// This is required to be serialized and deserialized as a byte array as serde does not
/// implement by default for arrays of size greater than 32 bytes.
#[cfg(feature = "serde")]
#[serde_as]
#[derive(serde::Serialize, serde::Deserialize, Clone, Debug, Eq, PartialEq)]
pub struct EcdsaPublicKeyArray(#[serde_as(as = "serde_with::Bytes")] pub [u8; 33]);

/// EcdsaPublicKeyArray is a 33-byte array representing the public key in compressed format.
/// This is required to be serialized and deserialized as a byte array as serde does not
/// implement by default for arrays of size greater than 32 bytes.
#[cfg(not(feature = "serde"))]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct EcdsaPublicKeyArray(pub [u8; 33]);

impl From<[u8; 33]> for EcdsaPublicKeyArray {
    fn from(array: [u8; 33]) -> Self {
        EcdsaPublicKeyArray(array)
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use crate::privatekey::ThresholdPrivateKey;
    use generic_ec::{Curve, SecretScalar};
    use rand::rngs::OsRng;

    pub fn generate_locally<E: Curve>() -> Option<ThresholdPrivateKey<E>> {
        let mut csprng = OsRng;
        ThresholdPrivateKey::from_scalar(SecretScalar::<E>::random(&mut csprng))
    }

    #[test]
    fn test_from_private_key_256k1() {
        let sk = generate_locally::<generic_ec::curves::Secp256k1>().unwrap();
        let pk = ThresholdPublicKey::from_private_key(&sk);

        assert_eq!(pk.as_point().is_zero(), false);
    }

    #[test]
    fn test_from_private_key_25519() {
        let sk = generate_locally::<generic_ec::curves::Ed25519>().unwrap();
        let pk = ThresholdPublicKey::from_private_key(&sk);

        assert_eq!(pk.as_point().is_zero(), false);
    }

    #[test]
    fn test_from_point_256k1() {
        let point = Point::<generic_ec::curves::Secp256k1>::generator().to_point();
        let pk = ThresholdPublicKey::from_point(point);

        assert!(pk.is_ok());
    }

    #[test]
    fn test_from_point_25519() {
        let point = Point::<generic_ec::curves::Ed25519>::generator().to_point();
        let pk = ThresholdPublicKey::from_point(point);

        assert!(pk.is_ok());
    }

    #[test]
    fn test_as_point_256k1() {
        let sk = generate_locally::<generic_ec::curves::Secp256k1>().unwrap();
        let pk = ThresholdPublicKey::from_private_key(&sk);

        assert!(!pk.as_point().is_zero());
    }

    #[test]
    fn test_as_point_25519() {
        let sk = generate_locally::<generic_ec::curves::Ed25519>().unwrap();
        let pk = ThresholdPublicKey::from_private_key(&sk);

        assert!(!pk.as_point().is_zero());
    }

    #[test]
    fn test_from_bytes_to_byte_256k1() {
        let sk = generate_locally::<generic_ec::curves::Secp256k1>().unwrap();
        let pk = ThresholdPrivateKey::public_key(&sk);
        // Test compressed conversion
        let pk_bytes_uncompressed = pk.clone().to_bytes(false);
        let pk_decoded_uncompressed = ThresholdPublicKey::from_bytes(pk_bytes_uncompressed).unwrap();
        assert_eq!(pk_decoded_uncompressed, pk.clone());
        // Test uncompressed conversion
        let pk_bytes_compressed = pk.clone().to_bytes(false);
        let pk_decoded_compressed = ThresholdPublicKey::from_bytes(pk_bytes_compressed).unwrap();
        assert_eq!(pk_decoded_compressed, pk);
    }

    #[test]
    fn test_from_bytes_to_byte_25519() {
        let sk = generate_locally::<generic_ec::curves::Ed25519>().unwrap();
        let pk = ThresholdPrivateKey::public_key(&sk);
        let pk_bytes = pk.clone().to_bytes(false);
        let pk_decoded = ThresholdPublicKey::from_bytes(pk_bytes).unwrap();
        assert_eq!(pk_decoded, pk.clone());
    }
}
