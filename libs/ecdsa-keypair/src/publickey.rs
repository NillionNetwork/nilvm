//! The ecdsa public key implementation.

use crate::privatekey::EcdsaPrivateKey;

use generic_ec::{curves::Secp256k1, errors::InvalidPoint, NonZero, Point};
use std::ops::Mul;
use thiserror::Error;

/// EcdsaPublicKey represents an elliptic curve public key used for ECDSA signatures
#[derive(Debug, PartialEq, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EcdsaPublicKey(NonZero<Point<Secp256k1>>);

impl EcdsaPublicKey {
    /// Compute a [`EcdsaPublicKey`] from a private [`EcdsaPrivateKey`] value.
    ///
    /// # Arguments
    ///
    /// * `private_key` - Reference to the [`EcdsaPrivateKey`] from which the public key is derived.
    ///
    /// The public key is generated by multiplying the elliptic curve generator by the private key scalar value.
    ///
    /// # Returns
    ///
    /// * A new [`EcdsaPublicKey`] that corresponds to the provided private key.
    ///
    /// # Example
    ///
    /// ```
    /// use generic_ec::curves::Secp256k1;
    /// use generic_ec::SecretScalar;
    /// use ecdsa_keypair::privatekey::EcdsaPrivateKey;
    /// use ecdsa_keypair::publickey::EcdsaPublicKey;
    /// use rand::rngs::OsRng;
    ///
    /// let mut csprng = OsRng;
    /// let sk = EcdsaPrivateKey::from_scalar(SecretScalar::<Secp256k1>::random(&mut csprng)).unwrap();
    /// let pk = EcdsaPublicKey::from_private_key(&sk);
    ///
    /// assert_eq!(pk.as_point().is_zero(), false);
    /// ```
    pub fn from_private_key(private_key: &EcdsaPrivateKey) -> Self {
        // pk = generator * sk
        let pk: NonZero<Point<Secp256k1>> =
            Point::<Secp256k1>::generator().to_nonzero_point().mul(private_key.as_non_zero_scalar());
        Self(pk)
    }

    /// Convert a [`Point`] into a [`EcdsaPublicKey`].
    ///
    /// # Arguments
    ///
    /// * `point` - A [`Point`] on the elliptic curve.
    ///
    /// Attempts to convert the provided point into a valid non-zero point to be used as the public key.
    /// Returns an error if the point is invalid or the identity point.
    ///
    /// # Returns
    ///
    /// * A result with a new [`EcdsaPublicKey`] or an error.
    ///
    /// # Errors
    ///
    /// * [`EcdsaPublicKeyError::ZeroPoint`] if the point is the identity point.
    ///
    /// # Example
    ///
    /// ```
    /// use generic_ec::curves::Secp256k1;
    /// use generic_ec::Point;
    /// use ecdsa_keypair::publickey::EcdsaPublicKey;
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = EcdsaPublicKey::from_point(point);
    ///
    /// assert!(pk.is_ok());
    /// ```
    pub fn from_point(point: Point<Secp256k1>) -> Result<Self, EcdsaPublicKeyError> {
        NonZero::from_point(point).map(Self).ok_or(EcdsaPublicKeyError::ZeroPoint)
    }

    /// Borrow the inner [`Point`] from this [`EcdsaPublicKey`].
    ///
    /// In elliptic curve cryptography, public keys are represented by points on the elliptic curve.
    ///
    /// # Returns
    ///
    /// * A reference to the inner [`Point`] representing the public key.
    ///
    /// # Example
    ///
    /// ```
    /// use ecdsa_keypair::publickey::EcdsaPublicKey;
    /// use generic_ec::Point;
    /// use generic_ec::curves::Secp256k1;
    /// use rand::rngs::OsRng;
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = EcdsaPublicKey::from_point(point).unwrap();
    ///
    /// assert!(!pk.as_point().is_zero());
    /// ```
    pub fn as_point(&self) -> &Point<Secp256k1> {
        &self.0
    }

    /// Decode an elliptic curve point (compressed or uncompressed) from the `Elliptic-Curve-Point-to-Octet-String` encoding,
    /// as described in SEC 1: Elliptic Curve Cryptography (Version 2.0), section 2.3.3., <http://www.secg.org/sec1-v2.pdf>.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A byte array or reference to a byte array that contains the encoded elliptic curve point.
    ///
    /// # Returns
    ///
    /// * A result with a new [`EcdsaPublicKey`] or an error.
    ///
    /// # Errors
    ///
    /// * [`EcdsaPublicKeyError::InvalidPoint`] if the point fails to decode properly.
    ///
    /// # Example
    ///
    /// ```
    /// use ecdsa_keypair::publickey::EcdsaPublicKey;
    /// use generic_ec::curves::Secp256k1;
    /// use generic_ec::Point;
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = EcdsaPublicKey::from_point(point).unwrap();
    /// let bytes = pk.to_bytes(false);
    ///
    /// let decoded_pk = EcdsaPublicKey::from_bytes(bytes);
    /// assert!(decoded_pk.is_ok());
    /// ```
    pub fn from_bytes(bytes: impl AsRef<[u8]>) -> Result<Self, EcdsaPublicKeyError> {
        let point = Point::from_bytes(bytes)?;
        EcdsaPublicKey::from_point(point)
    }

    /// Encode the elliptic curve public key point into a byte array.
    ///
    /// # Arguments
    ///
    /// * `compressed` - A boolean indicating whether to compress the point or not.
    ///
    /// # Returns
    ///
    /// * A `Vec<u8>` containing the encoded elliptic curve point.
    ///
    /// # Example
    ///
    /// ```
    /// use generic_ec::curves::Secp256k1;
    /// use generic_ec::Point;
    /// use ecdsa_keypair::publickey::EcdsaPublicKey;
    /// use ecdsa_keypair::{COMPRESSED_PUBLIC_KEY_LENGTH, UNCOMPRESSED_PUBLIC_KEY_LENGTH};
    ///
    /// let point = Point::<Secp256k1>::generator().to_point();
    /// let pk = EcdsaPublicKey::from_point(point).unwrap();
    ///
    /// let comp_encoded = pk.clone().to_bytes(true);
    /// assert_eq!(comp_encoded.len(), COMPRESSED_PUBLIC_KEY_LENGTH);
    ///
    /// let uncomp_encoded = pk.to_bytes(false);
    /// assert_eq!(uncomp_encoded.len(), UNCOMPRESSED_PUBLIC_KEY_LENGTH);
    /// ```
    pub fn to_bytes(self, compressed: bool) -> Vec<u8> {
        self.0.to_bytes(compressed).to_vec()
    }
}

/// Represents errors that can occur when working with an [`EcdsaPublicKey`].
#[derive(Error, Debug)]
pub enum EcdsaPublicKeyError {
    /// Error when the point provided is invalid or cannot be interpreted as a valid elliptic curve point.
    #[error("Invalid point for public key")]
    InvalidPointError(InvalidPoint),
    /// Error when the identity point is used to create an [`EcdsaPublicKey`].
    #[error("Identity point used to create ecdsa public key")]
    ZeroPoint,
}

// Implement the From trait to convert InvalidPoint into EcdsaPublicKeyError
impl From<InvalidPoint> for EcdsaPublicKeyError {
    fn from(error: InvalidPoint) -> Self {
        EcdsaPublicKeyError::InvalidPointError(error)
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use crate::privatekey::EcdsaPrivateKey;
    use generic_ec::SecretScalar;
    use rand::rngs::OsRng;

    pub fn generate_locally() -> Option<EcdsaPrivateKey> {
        let mut csprng = OsRng;
        EcdsaPrivateKey::from_scalar(SecretScalar::<Secp256k1>::random(&mut csprng))
    }

    #[test]
    fn test_from_private_key() {
        let sk = generate_locally().unwrap();
        let pk = EcdsaPublicKey::from_private_key(&sk);

        assert_eq!(pk.as_point().is_zero(), false);
    }

    #[test]
    fn test_from_point() {
        let point = Point::<Secp256k1>::generator().to_point();
        let pk = EcdsaPublicKey::from_point(point);

        assert!(pk.is_ok());
    }

    #[test]
    fn test_as_point() {
        let sk = generate_locally().unwrap();
        let pk = EcdsaPublicKey::from_private_key(&sk);

        assert!(!pk.as_point().is_zero());
    }

    #[test]
    fn test_from_bytes_to_bytes() {
        let sk = generate_locally().unwrap();
        let pk = EcdsaPrivateKey::public_key(&sk);
        // Test compressed conversion
        let pk_bytes_uncompressed = pk.clone().to_bytes(false);
        let pk_decoded_uncompressed = EcdsaPublicKey::from_bytes(pk_bytes_uncompressed).unwrap();
        assert_eq!(pk_decoded_uncompressed, pk.clone());
        // Test uncompressed conversion
        let pk_bytes_compressed = pk.clone().to_bytes(false);
        let pk_decoded_compressed = EcdsaPublicKey::from_bytes(pk_bytes_compressed).unwrap();
        assert_eq!(pk_decoded_compressed, pk);
    }
}
