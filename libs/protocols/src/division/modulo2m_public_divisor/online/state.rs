//! Mod2m protocol.

use crate::{
    conditionals::less_than::online::state::{Comparands, CompareState, CompareStateMessage},
    division::modulo2m_public_divisor::offline::PrepModulo2mShares,
    reveal::state::{PartySecretMismatch, RevealMode, RevealState, RevealStateMessage},
};
use anyhow::{anyhow, Error};
use basic_types::PartyMessage;
use math_lib::{
    errors::DivByZero,
    modular::{EncodedModularNumber, ModularInverse, ModularNumber, ModularPow, SafePrime, TryIntoU64},
};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    state::StateMachineMessage, StateMachine, StateMachineOutput, StateMachineState, StateMachineStateExt,
    StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

type RandomVector<T> = Vec<ModularNumber<T>>;

/// The MOD2M/TRUNC protocol state definitions.
pub mod states {
    use crate::{
        conditionals::less_than::CompareStateMachine, division::modulo2m_public_divisor::offline::PrepModulo2mShares,
        reveal::RevealStateMachine,
    };
    use math_lib::{
        fields::PrimeField,
        modular::{ModularNumber, SafePrime},
    };
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// Variant of the protocol
    pub enum Mod2mTruncVariant {
        /// MOD2M protocol variant
        Mod2m,
        /// TRUNC protocol variant
        Trunc,
    }

    /// The protocol is waiting for c variable REVEAL.
    pub struct WaitingRevealC<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The REVEAL state machine.
        pub(crate) reveal_state_machine: RevealStateMachine<PrimeField<T>, ShamirSecretSharer<T>>,

        /// The secret sharer we're using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The shares previously generated by PREP-MODULO.
        pub(crate) prep_elements: Vec<PrepModulo2mShares<T>>,

        /// The r' elements computed.
        pub(crate) r_prime: Vec<ModularNumber<T>>,

        /// The shared dividend.
        pub dividends: Vec<ModularNumber<T>>,

        /// The divisors 2^m.
        pub(crate) two_to_m: Vec<ModularNumber<T>>,

        /// The revealed c.
        pub(crate) c_variable: Vec<ModularNumber<T>>,

        /// The protocol variant: MOD2M or TRUNC
        pub(crate) protocol_variant: Mod2mTruncVariant,
    }

    /// The protocol is waiting for COMPARE against c.
    pub struct WaitingCComparison<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The COMPARE state machine.
        pub(crate) compare_state_machine: CompareStateMachine<T>,

        /// The r' elements computed.
        pub(crate) r_prime: Vec<ModularNumber<T>>,

        /// The shared dividend.
        pub dividends: Vec<ModularNumber<T>>,

        /// The divisors 2^m.
        pub(crate) two_to_m: Vec<ModularNumber<T>>,

        /// The revealed c'.
        pub(crate) c_prime_variable: Vec<ModularNumber<T>>,

        /// The result of COMPARE between c' and [r'].
        pub(crate) u: Vec<ModularNumber<T>>,

        /// The protocol variant: MOD2M or TRUNC
        pub(crate) protocol_variant: Mod2mTruncVariant,
    }
}

/// The input shared dividend and public divisor involved in the mod operation.
#[derive(Clone, Debug)]
pub struct Modulo2mShares<T>
where
    T: SafePrime,
{
    /// The shared dividend.
    pub dividend: ModularNumber<T>,

    /// The exponent of the divisors 2^m.
    pub divisors_exp_m: ModularNumber<T>,

    /// The preprocessing elements neeed for this modulo.
    pub prep_elements: PrepModulo2mShares<T>,
}

/// The state machine for the Modulo2m protocol.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<Modulo2mStateMessage>",
    output_message = "Modulo2mStateMessage",
    final_result = "Vec<ModularNumber<T>>",
    handle_message_fn = "Self::handle_message"
)]
pub enum Modulo2mState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for the c value REVEAL.
    #[state_machine(submachine = "state.reveal_state_machine", transition_fn = "Self::transition_waiting_reveal_c")]
    WaitingRevealC(states::WaitingRevealC<T>),

    /// We are waiting for the COMPARISON with the c value.
    #[state_machine(
        submachine = "state.compare_state_machine",
        transition_fn = "Self::transition_waiting_comparison_with_c"
    )]
    WaitingCComparison(states::WaitingCComparison<T>),
}

use self::states::Mod2mTruncVariant;
use crate::random::random_bitwise::bitwise_shares::merge_bits;
use Modulo2mState::*;

impl<T> Modulo2mState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new modulo MOD2M state.
    pub fn new(
        modulo_elements: Vec<Modulo2mShares<T>>,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
        kappa: usize,
        k: usize,
        protocol_variant: Mod2mTruncVariant,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), Modulo2mCreateError> {
        for mod_element in modulo_elements.iter() {
            let m_element = mod_element
                .divisors_exp_m
                .into_value()
                .try_into_u64()
                .map_err(|_err| Modulo2mCreateError::IntegerOverflow)? as usize;
            if m_element >= k {
                return Err(Modulo2mCreateError::DivisorTooLarge);
            }
        }

        // Step 1 and 2
        let (r_prime, r_dprime) = Self::build_random_shared_values(&modulo_elements, k, kappa)?;

        let mut two_to_m = Vec::new();
        let two = ModularNumber::<T>::two();
        for m in modulo_elements.iter() {
            two_to_m.push(two.exp_mod(&m.divisors_exp_m.into_value()));
        }

        // Step 3
        let b_elements = Self::build_b_share(&modulo_elements, &two_to_m, &r_prime, r_dprime, k)?;

        // Step 4
        let dividends = modulo_elements.iter().map(|mod_element| mod_element.dividend).collect();
        let prep_elements = modulo_elements.into_iter().map(|mod_element| mod_element.prep_elements).collect();
        let (reveal_state, messages) = RevealState::new(RevealMode::new_all(b_elements), secret_sharer.clone())?;
        let next_state = states::WaitingRevealC {
            reveal_state_machine: StateMachine::new(reveal_state),
            secret_sharer,
            prep_elements,
            r_prime,
            dividends,
            two_to_m,
            c_variable: Vec::new(),
            protocol_variant,
        };
        let messages = messages.into_iter().map(|message| message.wrap(&Modulo2mStateMessage::CReveal)).collect();
        Ok((WaitingRevealC(next_state), messages))
    }

    #[allow(clippy::indexing_slicing)]
    fn transition_waiting_reveal_c(state: states::WaitingRevealC<T>) -> StateMachineStateResult<Self> {
        // Step 6
        let c_prime_variable = Self::build_c_prime_variable(state.c_variable, &state.two_to_m)
            .map_err(|e| anyhow!("build c' shared values failed: {e}"))?;

        // Step 7
        let comparands: Vec<Comparands<T>> =
            Self::build_comparands_c_r(&c_prime_variable, &state.r_prime, &state.prep_elements)
                .map_err(|e| anyhow!("build comparands failed: {e}"))?;
        let (compare_state, messages) = CompareState::new(comparands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create COMPARE state: {e}"))?;
        let next_state = states::WaitingCComparison {
            compare_state_machine: StateMachine::new(compare_state),
            r_prime: state.r_prime,
            dividends: state.dividends,
            two_to_m: state.two_to_m,
            c_prime_variable,
            u: Vec::new(),
            protocol_variant: state.protocol_variant,
        };
        let messages = messages.into_iter().map(|message| message.wrap(&Modulo2mStateMessage::CComparison)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingCComparison(next_state), messages))
    }

    #[allow(clippy::indexing_slicing)]
    fn transition_waiting_comparison_with_c(state: states::WaitingCComparison<T>) -> StateMachineStateResult<Self> {
        // Step 9
        let a_primes = Self::build_a_prime(state.c_prime_variable, state.r_prime, &state.two_to_m, state.u)
            .map_err(|e| anyhow!("build a' shared values failed: {e}"))?;
        let output = match state.protocol_variant {
            states::Mod2mTruncVariant::Trunc => {
                // Step 10
                Self::build_trunc_outputs(state.dividends, a_primes, state.two_to_m)?
            }
            states::Mod2mTruncVariant::Mod2m => a_primes,
        };
        // Step 10/11
        Ok(StateMachineStateOutput::Final(output))
    }

    fn handle_message(mut state: Self, message: PartyMessage<Modulo2mStateMessage>) -> StateMachineStateResult<Self> {
        use Modulo2mStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (CReveal(message), WaitingRevealC(inner)) => {
                match inner.reveal_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.c_variable = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, Modulo2mStateMessage::CReveal),
                }
            }
            (CComparison(message), WaitingCComparison(inner)) => {
                match inner.compare_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.u = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, Modulo2mStateMessage::CComparison),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }

    fn build_random_shared_values(
        modulo_elements: &[Modulo2mShares<T>],
        k: usize,
        kappa: usize,
    ) -> Result<(RandomVector<T>, RandomVector<T>), Modulo2mCreateError> {
        let mut r_prime = Vec::new();
        let mut r_dprime = Vec::new();
        for mod_element in modulo_elements {
            let m_element = mod_element
                .divisors_exp_m
                .into_value()
                .try_into_u64()
                .map_err(|_err| Modulo2mCreateError::IntegerOverflow)? as usize;
            let k_plus_kappa = k.checked_add(kappa).ok_or(Modulo2mCreateError::IntegerOverflow)?;
            if mod_element.prep_elements.ran_bits_r.shares().len() != k_plus_kappa {
                return Err(Modulo2mCreateError::ExpectedSharedRandomBits(
                    k_plus_kappa,
                    mod_element.prep_elements.ran_bits_r.shares().len(),
                ));
            }
            let r_p_bits = mod_element
                .prep_elements
                .ran_bits_r
                .shares()
                .get(0..m_element)
                .ok_or(Modulo2mCreateError::OutOfBounds)?;
            let r_dp_bits = mod_element
                .prep_elements
                .ran_bits_r
                .shares()
                .get(m_element..)
                .ok_or(Modulo2mCreateError::OutOfBounds)?;
            let r_p = merge_bits(r_p_bits);
            let r_dp = merge_bits(r_dp_bits);
            r_prime.push(r_p);
            r_dprime.push(r_dp);
        }
        Ok((r_prime, r_dprime))
    }

    fn build_b_share(
        modulo_elements: &[Modulo2mShares<T>],
        two_to_m: &[ModularNumber<T>],
        r_prime: &[ModularNumber<T>],
        r_dprime: Vec<ModularNumber<T>>,
        k: usize,
    ) -> Result<Vec<ModularNumber<T>>, Modulo2mCreateError> {
        let k_minus_one = k.checked_sub(1).ok_or(Modulo2mCreateError::IntegerOverflow)?;
        let two_to_k_minus_one = ModularNumber::two().exp_mod(&T::Normal::from(k_minus_one as u64));

        let mut b_elements = Vec::new();
        for (((mod_element, r_p), r_dp), two_m) in
            modulo_elements.iter().zip(r_prime.iter()).zip(r_dprime.into_iter()).zip(two_to_m.iter())
        {
            let mut b = two_to_k_minus_one + &mod_element.dividend;
            let term = r_dp * two_m;
            b = b + &term;
            b = b + r_p;
            b_elements.push(b);
        }
        Ok(b_elements)
    }

    fn build_c_prime_variable(
        c_variable: Vec<ModularNumber<T>>,
        two_to_m: &[ModularNumber<T>],
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let mut c_prime = Vec::new();
        for (c, two_m) in c_variable.into_iter().zip(two_to_m.iter()) {
            let c_p = (c % two_m)?;
            c_prime.push(c_p);
        }
        Ok(c_prime)
    }

    fn build_comparands_c_r(
        c_variable: &[ModularNumber<T>],
        r_prime: &[ModularNumber<T>],
        prep_elements: &[PrepModulo2mShares<T>],
    ) -> Result<Vec<Comparands<T>>, Error> {
        let zipped = c_variable.iter().zip(r_prime.iter()).zip(prep_elements.iter());
        let mut comparands = Vec::new();

        for ((c, r_p), prep_element) in zipped {
            let prep_compare = prep_element
                .prep_compare
                .first()
                .ok_or(anyhow!("failed to get prep_compare from preprocessing elements in mod2m operation"))?;
            let comparand = Comparands { left: *c, right: *r_p, prep_elements: prep_compare.clone() };
            comparands.push(comparand);
        }
        Ok(comparands)
    }

    fn build_a_prime(
        c_primes: Vec<ModularNumber<T>>,
        r_primes: Vec<ModularNumber<T>>,
        two_to_m: &[ModularNumber<T>],
        us: Vec<ModularNumber<T>>,
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let zipped = c_primes.iter().zip(r_primes.iter()).zip(two_to_m.iter()).zip(us.iter());
        let mut a_primes = Vec::new();
        for (((c, r), two_m), u) in zipped {
            let mut a_prime = c - r;
            let term = two_m * u;
            a_prime = a_prime + &term;
            a_primes.push(a_prime);
        }
        Ok(a_primes)
    }

    // [d] = ([a] - [a'])(2^{-m} \mod q);
    fn build_trunc_outputs(
        dividends: Vec<ModularNumber<T>>,
        a_primes: Vec<ModularNumber<T>>,
        two_to_m: Vec<ModularNumber<T>>,
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let zipped = dividends.iter().zip(a_primes.iter()).zip(two_to_m.iter());
        let mut trunc_outputs = Vec::new();
        for ((a, a_prime), two_m) in zipped {
            let mut d = a - a_prime;
            let inv_two_m = two_m.inverse();
            d = d * &inv_two_m;
            trunc_outputs.push(d);
        }
        Ok(trunc_outputs)
    }
}

/// A message for this state machine.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum Modulo2mStateMessage {
    /// A message for the REVEAL state machine.
    CReveal(RevealStateMessage<EncodedModularNumber>) = 0,

    /// A message for the msecond COMPARISON state machine.
    CComparison(CompareStateMessage) = 1,
}

/// An error during the PUB-MULT state construction.
#[derive(thiserror::Error, Debug)]
pub enum Modulo2mCreateError {
    /// An error during the REVEAL creation.
    #[error("REVEAL: {0}")]
    Reveal(#[from] PartySecretMismatch),

    /// An error when m > k
    #[error("The size of divisor (m) is larger than the allowed size (k)")]
    DivisorTooLarge,

    /// Integer overflow error.
    #[error("integer overflow")]
    IntegerOverflow,

    /// An error with custom message and parameters
    #[error("Expected {0} shared random bits, got {1}")]
    ExpectedSharedRandomBits(usize, usize),

    /// An arithmetic error.
    #[error("arithmetic: {0}")]
    Arithmetic(#[from] DivByZero),

    /// Value is out of bounds
    #[error("out of bounds")]
    OutOfBounds,
}
