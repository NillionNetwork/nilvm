//! Modulo protocol.

use super::super::offline::PrepModuloShares;
use crate::{
    conditionals::less_than::online::state::{Comparands, CompareState, CompareStateMessage},
    reveal::state::{PartySecretMismatch, RevealMode, RevealState, RevealStateMessage},
};
use anyhow::{anyhow, Error};
use basic_types::PartyMessage;
use math_lib::{
    errors::DivByZero,
    modular::{AsBits, EncodedModularNumber, ModularNumber, ModularPow, SafePrime},
};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    state::StateMachineMessage, StateMachine, StateMachineOutput, StateMachineState, StateMachineStateExt,
    StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

type RandomVector<T> = Vec<ModularNumber<T>>;

/// The modulo public divisor protocol state definitions.
pub mod states {
    use crate::{
        conditionals::less_than::CompareStateMachine, division::modulo_public_divisor::offline::PrepModuloShares,
        reveal::RevealStateMachine,
    };
    use math_lib::{
        fields::PrimeField,
        modular::{ModularNumber, SafePrime},
    };
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// The protocol is waiting for c variable REVEAL.
    pub struct WaitingRevealC<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The REVEAL state machine.
        pub(crate) reveal_state_machine: RevealStateMachine<PrimeField<T>, ShamirSecretSharer<T>>,

        /// The secret sharer we're using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The shares previously generated by PREP-MODULO.
        pub(crate) prep_elements: Vec<PrepModuloShares<T>>,

        /// The r' elements computed.
        pub(crate) r_prime: Vec<ModularNumber<T>>,

        /// The 2^(k-1) variable.
        pub(crate) two_k_minus_one: ModularNumber<T>,

        /// The divisors d.
        pub(crate) divisors: Vec<ModularNumber<T>>,

        /// The revealed c.
        pub(crate) c_variable: Vec<ModularNumber<T>>,

        // Sign changes for outputs.
        pub(crate) signs: Vec<bool>,
    }

    /// The protocol is waiting for COMPARE against random value.
    pub struct WaitingRandomComparison<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The COMPARE state machine.
        pub(crate) compare_state_machine: CompareStateMachine<T>,

        /// The secret sharer we're using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The shares previously generated by PREP-MODULO.
        pub(crate) prep_elements: Vec<PrepModuloShares<T>>,

        /// The r' elements computed.
        pub(crate) r_prime: Vec<ModularNumber<T>>,

        /// The divisors d.
        pub(crate) divisors: Vec<ModularNumber<T>>,

        /// The revealed c'.
        pub(crate) c_prime_variable: Vec<ModularNumber<T>>,

        /// The result of 1 - COMPARE between random and divisor.
        pub(crate) v: Vec<ModularNumber<T>>,

        // Sign changes for outputs.
        pub(crate) signs: Vec<bool>,
    }

    /// The protocol is waiting for COMPARE against c.
    pub struct WaitingCComparison<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The COMPARE state machine.
        pub(crate) compare_state_machine: CompareStateMachine<T>,

        /// The r' elements computed.
        pub(crate) r_prime: Vec<ModularNumber<T>>,

        /// The divisors d.
        pub(crate) divisors: Vec<ModularNumber<T>>,

        /// The revealed c'.
        pub(crate) c_prime_variable: Vec<ModularNumber<T>>,

        /// The result of 1 - COMPARE between random and divisor.
        pub(crate) v: Vec<ModularNumber<T>>,

        /// The result of COMPARE between c and [r'] - d*[v].
        pub(crate) u: Vec<ModularNumber<T>>,

        // Sign changes for outputs.
        pub(crate) signs: Vec<bool>,
    }
}

/// The input shared dividend and public divisor involved in the mod operation.
#[derive(Clone, Debug)]
pub struct ModuloShares<T>
where
    T: SafePrime,
{
    /// The shared dividend.
    pub dividend: ModularNumber<T>,

    /// The public divisor.
    pub divisor: ModularNumber<T>,

    /// The preprocessing elements neeed for this modulo.
    pub prep_elements: PrepModuloShares<T>,
}

/// The state machine for the modulo state protocol.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<ModuloStateMessage>",
    output_message = "ModuloStateMessage",
    final_result = "Vec<ModularNumber<T>>",
    handle_message_fn = "Self::handle_message"
)]
pub enum ModuloState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for the c value REVEAL.
    #[state_machine(submachine = "state.reveal_state_machine", transition_fn = "Self::transition_waiting_reveal_c")]
    WaitingRevealC(states::WaitingRevealC<T>),

    /// We are waiting for the COMPARISON with random.
    #[state_machine(
        submachine = "state.compare_state_machine",
        transition_fn = "Self::transition_waiting_comparison_with_random"
    )]
    WaitingRandomComparison(states::WaitingRandomComparison<T>),

    /// We are waiting for the COMPARISON with the c value.
    #[state_machine(
        submachine = "state.compare_state_machine",
        transition_fn = "Self::transition_waiting_comparison_with_c"
    )]
    WaitingCComparison(states::WaitingCComparison<T>),
}

use crate::random::random_bitwise::bitwise_shares::merge_bits;
use ModuloState::*;

impl<T> ModuloState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    fn top(dividend: ModularNumber<T>, divisor: ModularNumber<T>) -> ModularNumber<T> {
        let mut res = dividend;
        if !divisor.is_positive() {
            res = -dividend;
        }
        res
    }

    /// Construct a new modulo MODULO state.
    pub fn new(
        modulo_elements: Vec<ModuloShares<T>>,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
        kappa: usize,
        k: usize,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), ModuloCreateError> {
        let signs = modulo_elements.iter().map(|m| m.divisor == m.divisor.abs()).collect();

        let modulo_elements: Vec<_> = modulo_elements
            .into_iter()
            .map(|m| ModuloShares {
                dividend: Self::top(m.dividend, m.divisor),
                divisor: m.divisor.abs(),
                prep_elements: m.prep_elements,
            })
            .collect();

        // Step 1
        let m: Vec<usize> =
            modulo_elements.iter().map(|mod_elements| mod_elements.divisor.into_value().bits()).collect();
        for m in m.iter() {
            if m >= &k {
                return Err(ModuloCreateError::DivisorTooLarge);
            }
        }

        // Step 2 and 3
        let (r_prime, r_dprime) = Self::build_random_shared_values(&modulo_elements, m, k, kappa)?;

        // Step 4
        let k_minus_one = k.checked_sub(1).ok_or(ModuloCreateError::IntegerOverflow)?;
        let two_k_minus_one = ModularNumber::two().exp_mod(&T::Normal::from(k_minus_one as u64));
        let b_elements = Self::build_b_share(&modulo_elements, &r_prime, r_dprime, two_k_minus_one)?;

        // Step 5
        let divisors = modulo_elements.iter().map(|mod_element| mod_element.divisor).collect();
        let prep_elements = modulo_elements.into_iter().map(|mod_element| mod_element.prep_elements).collect();
        let (reveal_state, messages) = RevealState::new(RevealMode::new_all(b_elements), secret_sharer.clone())?;
        let next_state = states::WaitingRevealC {
            reveal_state_machine: StateMachine::new(reveal_state),
            secret_sharer,
            prep_elements,
            r_prime,
            two_k_minus_one,
            divisors,
            c_variable: Vec::new(),
            signs,
        };
        let messages = messages.into_iter().map(|message| message.wrap(&ModuloStateMessage::CReveal)).collect();
        Ok((WaitingRevealC(next_state), messages))
    }

    #[allow(clippy::indexing_slicing)]
    fn transition_waiting_reveal_c(state: states::WaitingRevealC<T>) -> StateMachineStateResult<Self> {
        // Step 6
        let c_prime_variable = Self::build_c_prime_variable(state.c_variable, &state.divisors, state.two_k_minus_one)
            .map_err(|e| anyhow!("build c' shared values failed: {e}"))?;

        // Step 7
        let comparands: Vec<Comparands<T>> =
            Self::build_comparands_r_d(&state.r_prime, &state.divisors, &state.prep_elements)
                .map_err(|e| anyhow!("build comparands failed: {e}"))?;
        let (compare_state, messages) = CompareState::new(comparands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create COMPARE state: {e}"))?;
        let next_state = states::WaitingRandomComparison {
            compare_state_machine: StateMachine::new(compare_state),
            secret_sharer: state.secret_sharer,
            prep_elements: state.prep_elements,
            r_prime: state.r_prime,
            divisors: state.divisors,
            c_prime_variable,
            v: Vec::new(),
            signs: state.signs,
        };
        let messages =
            messages.into_iter().map(|message| message.wrap(&ModuloStateMessage::RandomComparison)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingRandomComparison(next_state), messages))
    }

    #[allow(clippy::indexing_slicing)]
    fn transition_waiting_comparison_with_random(
        state: states::WaitingRandomComparison<T>,
    ) -> StateMachineStateResult<Self> {
        // Step 8
        let r_minus_d_times_v = Self::build_r_minus_d_times_v(&state.r_prime, &state.divisors, &state.v)
            .map_err(|e| anyhow!("build [r'] - d*[v] shared values failed: {e}"))?;
        let comparands: Vec<Comparands<T>> =
            Self::build_comparands_c_r_d_v(&state.c_prime_variable, r_minus_d_times_v, state.prep_elements)
                .map_err(|e| anyhow!("build comparands failed: {e}"))?;
        let (compare_state, messages) = CompareState::new(comparands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create COMPARE state: {e}"))?;
        let next_state = states::WaitingCComparison {
            compare_state_machine: StateMachine::new(compare_state),
            r_prime: state.r_prime,
            divisors: state.divisors,
            c_prime_variable: state.c_prime_variable,
            v: state.v,
            u: Vec::new(),
            signs: state.signs,
        };
        let messages = messages.into_iter().map(|message| message.wrap(&ModuloStateMessage::CComparison)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingCComparison(next_state), messages))
    }

    #[allow(clippy::indexing_slicing)]
    fn transition_waiting_comparison_with_c(state: states::WaitingCComparison<T>) -> StateMachineStateResult<Self> {
        // Step 9
        let a_primes =
            Self::build_a_prime(state.c_prime_variable, state.r_prime, state.divisors, state.v, state.u, state.signs)
                .map_err(|e| anyhow!("build a' shared values failed: {e}"))?;

        // Step 10
        Ok(StateMachineStateOutput::Final(a_primes))
    }

    fn handle_message(mut state: Self, message: PartyMessage<ModuloStateMessage>) -> StateMachineStateResult<Self> {
        use ModuloStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (CReveal(message), WaitingRevealC(inner)) => {
                match inner.reveal_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.c_variable = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, ModuloStateMessage::CReveal),
                }
            }
            (RandomComparison(message), WaitingRandomComparison(inner)) => {
                match inner.compare_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        // Step 7: compute 1 - ([r'] - d)
                        let one_minus_compare = Self::build_one_minus_compare(values)
                            .map_err(|e| anyhow!("failed to ccompute 1 - COMPARE: {e}"))?;
                        inner.v = one_minus_compare;
                        state.try_next()
                    }
                    output => state.wrap_message(output, ModuloStateMessage::RandomComparison),
                }
            }
            (CComparison(message), WaitingCComparison(inner)) => {
                match inner.compare_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.u = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, ModuloStateMessage::CComparison),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }

    fn build_random_shared_values(
        modulo_elements: &[ModuloShares<T>],
        m: Vec<usize>,
        k: usize,
        kappa: usize,
    ) -> Result<(RandomVector<T>, RandomVector<T>), ModuloCreateError> {
        let mut r_prime = Vec::new();
        let mut r_dprime = Vec::new();
        for (mod_element, m_element) in modulo_elements.iter().zip(m) {
            let k_plus_kappa = k.checked_add(kappa).ok_or(ModuloCreateError::IntegerOverflow)?;
            if mod_element.prep_elements.ran_bits_r.shares().len() != k_plus_kappa {
                return Err(ModuloCreateError::ExpectedSharedRandomBits(
                    k_plus_kappa,
                    mod_element.prep_elements.ran_bits_r.shares().len(),
                ));
            }
            let r_p_bits = mod_element
                .prep_elements
                .ran_bits_r
                .shares()
                .get(0..m_element)
                .ok_or(ModuloCreateError::OutOfBounds)?;
            let r_dp_bits =
                mod_element.prep_elements.ran_bits_r.shares().get(m_element..).ok_or(ModuloCreateError::OutOfBounds)?;
            let r_p = merge_bits(r_p_bits);
            let r_dp = merge_bits(r_dp_bits);
            r_prime.push(r_p);
            r_dprime.push(r_dp);
        }
        Ok((r_prime, r_dprime))
    }

    fn build_b_share(
        modulo_elements: &[ModuloShares<T>],
        r_prime: &[ModularNumber<T>],
        r_dprime: Vec<ModularNumber<T>>,
        two_k_minus_one: ModularNumber<T>,
    ) -> Result<Vec<ModularNumber<T>>, ModuloCreateError> {
        let mut b_elements = Vec::new();
        for ((mod_element, r_p), r_dp) in modulo_elements.iter().zip(r_prime.iter()).zip(r_dprime.into_iter()) {
            let mut b = two_k_minus_one + &mod_element.dividend;
            let term = mod_element.divisor * &r_dp;
            b = b + &term;
            b = b + r_p;
            b_elements.push(b);
        }
        Ok(b_elements)
    }

    fn build_c_prime_variable(
        c_variable: Vec<ModularNumber<T>>,
        divisors: &[ModularNumber<T>],
        two_k_minus_one: ModularNumber<T>,
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let mut c_prime = Vec::new();
        for (c, d) in c_variable.iter().zip(divisors.iter()) {
            let mut c_p = c - &two_k_minus_one;
            c_p = (c_p % d)?;
            c_prime.push(c_p);
        }
        Ok(c_prime)
    }

    fn build_comparands_r_d(
        r_prime: &[ModularNumber<T>],
        divisor: &[ModularNumber<T>],
        prep_elements: &[PrepModuloShares<T>],
    ) -> Result<Vec<Comparands<T>>, Error> {
        let zipped = r_prime.iter().zip(divisor.iter()).zip(prep_elements.iter());
        let mut comparands = Vec::new();

        for ((r_p, d), prep_element) in zipped {
            let prep_compare = prep_element
                .prep_compare
                .first()
                .ok_or(anyhow!("failed to get first prep_compare from preprocessing elements in modulo operation"))?;
            let comparand = Comparands { left: *r_p, right: *d, prep_elements: prep_compare.clone() };
            comparands.push(comparand);
        }
        Ok(comparands)
    }

    fn build_r_minus_d_times_v(
        r_prime: &[ModularNumber<T>],
        divisors: &[ModularNumber<T>],
        vs: &[ModularNumber<T>],
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let zipped = r_prime.iter().zip(divisors.iter()).zip(vs.iter());
        let mut r_minus_d_times_v = Vec::new();
        for ((r, d), v) in zipped {
            let term = d * v;
            let r_d_v = r - &term;
            r_minus_d_times_v.push(r_d_v);
        }
        Ok(r_minus_d_times_v)
    }

    fn build_comparands_c_r_d_v(
        c_prime: &[ModularNumber<T>],
        rdvs: Vec<ModularNumber<T>>,
        prep_elements: Vec<PrepModuloShares<T>>,
    ) -> Result<Vec<Comparands<T>>, Error> {
        let zipped = c_prime.iter().zip(rdvs.iter()).zip(prep_elements.iter());
        let mut comparands = Vec::new();

        for ((c, rdv), prep_element) in zipped {
            let prep_compare = prep_element
                .prep_compare
                .get(1)
                .ok_or(anyhow!("failed to get second prep_compare from preprocessing elements in modulo operation"))?;
            let comparand = Comparands { left: *c, right: *rdv, prep_elements: prep_compare.clone() };
            comparands.push(comparand);
        }
        Ok(comparands)
    }
    fn build_a_prime(
        c_primes: Vec<ModularNumber<T>>,
        r_primes: Vec<ModularNumber<T>>,
        divisors: Vec<ModularNumber<T>>,
        vs: Vec<ModularNumber<T>>,
        us: Vec<ModularNumber<T>>,
        signs: Vec<bool>,
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let zipped =
            c_primes.iter().zip(r_primes.iter()).zip(divisors.iter()).zip(vs.iter()).zip(us.iter()).zip(signs.iter());
        let mut a_primes = Vec::new();
        for (((((c, r), d), v), u), s) in zipped {
            let mut a_prime = c - r;
            let v_plus_u = v + u;
            let term = d * &v_plus_u;
            a_prime = a_prime + &term;
            if !s {
                a_prime = -a_prime;
            };
            a_primes.push(a_prime);
        }
        Ok(a_primes)
    }

    fn build_one_minus_compare(compare_results: Vec<ModularNumber<T>>) -> Result<Vec<ModularNumber<T>>, Error> {
        let mut one_minus_compares = Vec::new();
        for compare_result in compare_results {
            let one_minus_compare = ModularNumber::ONE - &compare_result;
            one_minus_compares.push(one_minus_compare);
        }
        Ok(one_minus_compares)
    }
}

/// A message for this state machine.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum ModuloStateMessage {
    /// A message for the REVEAL state machine.
    CReveal(RevealStateMessage<EncodedModularNumber>) = 0,

    /// A message for the first COMPARISON state machine.
    RandomComparison(CompareStateMessage) = 1,

    /// A message for the msecond COMPARISON state machine.
    CComparison(CompareStateMessage) = 2,
}

/// An error during the PUB-MULT state construction.
#[derive(thiserror::Error, Debug)]
pub enum ModuloCreateError {
    /// An error during the REVEAL creation.
    #[error("REVEAL: {0}")]
    Reveal(#[from] PartySecretMismatch),

    /// An error when m > k
    #[error("The size of divisor (m) is larger than the allowed size (k)")]
    DivisorTooLarge,

    /// Integer overflow error.
    #[error("integer overflow")]
    IntegerOverflow,

    /// An error with custom message and parameters
    #[error("Expected {0} shared random bits, got {1}")]
    ExpectedSharedRandomBits(usize, usize),

    /// An arithmetic error.
    #[error("arithmetic: {0}")]
    Arithmetic(#[from] DivByZero),

    /// Value is out of bounds
    #[error("out of bounds")]
    OutOfBounds,
}

#[allow(clippy::arithmetic_side_effects, clippy::indexing_slicing)]
#[cfg(test)]
mod test {
    use super::*;
    use crate::random::{random_bit::BitShare, random_bitwise::BitwiseNumberShares};

    type State = ModuloState<Prime>;

    use math_lib::modular::U64SafePrime;

    type Prime = U64SafePrime;

    #[test]
    fn random_share_from_bit_shares() {
        let bits = vec![
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ZERO),
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ONE),
        ];
        let value = merge_bits(&bits);
        assert_eq!(value, ModularNumber::from_u32(13));
    }

    #[test]
    fn random_shared_values_failed_size() {
        // The error comes from the fact that k + kappa = 6
        // and the lenght of the ran_bits_r is 4. These should match.
        let m = vec![2];
        let k = 3;
        let kappa = 3;
        let ran_bits_r = BitwiseNumberShares::from(vec![
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ZERO),
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ONE),
        ]);
        let perp_modulo_shares = PrepModuloShares {
            ran_bits_r: ran_bits_r.clone(),
            prep_compare: Vec::new(), // not being used for testing
        };
        let modulo_sharess = ModuloShares {
            dividend: ModularNumber::default(), // not being used for testing
            divisor: ModularNumber::default(),  // not being used for testing
            prep_elements: perp_modulo_shares,
        };
        let modulo_elements = vec![modulo_sharess];

        let output = State::build_random_shared_values(&modulo_elements, m, k, kappa);
        let _k_plus_kappa = k + &kappa;
        let _ran_bits_r_len = ran_bits_r.shares().len();
        assert!(matches!(output, Err(ModuloCreateError::ExpectedSharedRandomBits(_k_plus_kappa, _ran_bits_r_len))));
    }

    #[test]
    fn random_shared_values_failed_out_of_bounds() {
        // The error comes from the fact that m = 7 > 6 = k + kappa.
        let m = vec![7];
        let k = 2;
        let kappa = 2;
        let ran_bits_r = BitwiseNumberShares::from(vec![
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ZERO),
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ONE),
        ]);
        let perp_modulo_shares = PrepModuloShares {
            ran_bits_r: ran_bits_r.clone(),
            prep_compare: Vec::new(), // not being used for testing
        };
        let modulo_sharess = ModuloShares {
            dividend: ModularNumber::default(), // not being used for testing
            divisor: ModularNumber::default(),  // not being used for testing
            prep_elements: perp_modulo_shares,
        };
        let modulo_elements = vec![modulo_sharess];

        let output = State::build_random_shared_values(&modulo_elements, m, k, kappa);
        assert!(matches!(output, Err(ModuloCreateError::OutOfBounds)));
    }

    #[test]
    fn random_shared_values() {
        let m = vec![1];
        let k = 2;
        let kappa = 2;
        let ran_bits_r = BitwiseNumberShares::from(vec![
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ZERO),
            BitShare::from(ModularNumber::<Prime>::ONE),
            BitShare::from(ModularNumber::<Prime>::ONE),
        ]);
        let perp_modulo_shares = PrepModuloShares {
            ran_bits_r: ran_bits_r.clone(),
            prep_compare: Vec::new(), // not being used for testing
        };
        let modulo_sharess = ModuloShares {
            dividend: ModularNumber::default(), // not being used for testing
            divisor: ModularNumber::default(),  // not being used for testing
            prep_elements: perp_modulo_shares,
        };
        let modulo_elements = vec![modulo_sharess];

        let output = State::build_random_shared_values(&modulo_elements, m, k, kappa).expect("build failed");
        assert_eq!(output, (vec![ModularNumber::ONE], vec![ModularNumber::from_u32(6)]));
    }

    #[test]
    fn test_build_b_share() {
        // divisor = 7 = 111
        // m  = 3 = ceil(log(7)) < 5 = k
        let two_to_k_minus_1 = ModularNumber::from_u32(16);
        let perp_modulo_shares = PrepModuloShares {
            ran_bits_r: BitwiseNumberShares::from(vec![ModularNumber::ZERO]), // not being used for testing
            prep_compare: Vec::new(),                                         // not being used for testing
        };
        let modulo_sharess = ModuloShares {
            dividend: ModularNumber::from_u32(10),
            divisor: ModularNumber::from_u32(7),
            prep_elements: perp_modulo_shares, // not being used for testing
        };
        let modulo_elements = vec![modulo_sharess];
        let r_prime = vec![ModularNumber::two()];
        let r_dprime = vec![ModularNumber::from_u32(3)];
        let output =
            State::build_b_share(&modulo_elements, &r_prime, r_dprime, two_to_k_minus_1).expect("build failed");
        // 49 = 2^4 + 10 + 7 * 3 + 2 = 2^(k-1) + dividend + divisor * r'' + r'
        assert_eq!(output, vec![ModularNumber::from_u32(49)]);
    }

    #[test]
    fn test_build_c_prime_variable() {
        // divisor = 7 = 111
        // m  = 3 = ceil(log(7)) < 5 = k
        let c_variable = vec![ModularNumber::from_u32(49)];
        let divisor = vec![ModularNumber::from_u32(7)];
        let two_to_k_minus_1 = ModularNumber::from_u32(16);
        let output = State::build_c_prime_variable(c_variable, &divisor, two_to_k_minus_1).expect("build failed");
        // 5 = (49 - 2^4) mod 7 = ( c - 2^(k-1) ) mod divisor
        assert_eq!(output, vec![ModularNumber::from_u32(5)]);
    }

    #[test]
    fn test_build_r_minus_d_times_v() {
        // v = 0 as r' < divisor
        let r_prime = vec![ModularNumber::<Prime>::from_u32(2)];
        let divisor = vec![ModularNumber::from_u32(7)];
        let v: Vec<ModularNumber<_>> = vec![ModularNumber::ZERO];
        let output = State::build_r_minus_d_times_v(&r_prime, &divisor, &v).expect("build failed");
        // 2 = 2 - 7 * 0 = r' - divisor * v
        assert_eq!(output, vec![ModularNumber::two()]);

        // v = 1 as r' > divisor
        let r_prime = vec![ModularNumber::<Prime>::from_u32(8)];
        let divisor = vec![ModularNumber::from_u32(7)];
        let v: Vec<ModularNumber<_>> = vec![ModularNumber::ONE];
        let output = State::build_r_minus_d_times_v(&r_prime, &divisor, &v).expect("build failed");
        // 2 = 2 - 7 * 0 = r' - divisor * v
        assert_eq!(output, vec![ModularNumber::ONE]);
    }

    #[test]
    fn test_build_a_prime() {
        // v = 0 as r' < divisor
        // u = 0 as c' > r' - divisor * v
        let c_prime = vec![ModularNumber::<Prime>::from_u32(5)];
        let r_prime = vec![ModularNumber::<Prime>::from_u32(2)];
        let divisor = vec![ModularNumber::from_u32(7)];
        let v: Vec<ModularNumber<_>> = vec![ModularNumber::ZERO];
        let u: Vec<ModularNumber<_>> = vec![ModularNumber::<Prime>::ZERO];
        let signs = vec![true];
        let output = State::build_a_prime(c_prime, r_prime, divisor, v, u, signs).expect("build failed");
        // 3 = 5 - 2 + 7 * (0 + 0) = c' - r' + divisor * ( v + u )
        assert_eq!(output, vec![ModularNumber::from_u32(3)]);
    }

    #[test]
    fn test_build_one_minus_compare() {
        let compare: Vec<ModularNumber<_>> = vec![ModularNumber::<Prime>::ONE];
        let output = State::build_one_minus_compare(compare).expect("build failed");
        // 0 = 1 - 1 = 1 - compare
        assert_eq!(output, vec![ModularNumber::ZERO]);
    }
}
