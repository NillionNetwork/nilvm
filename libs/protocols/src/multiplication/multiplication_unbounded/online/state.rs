//! The UNBOUNDED-MULT protocol state machine.

use super::super::offline::state::{
    UnboundedMultPrepareError, UnboundedMultPrepareState, UnboundedMultPrepareStateMessage,
    UnboundedMultPrepareStateOutput,
};
use crate::{
    multiplication::multiplication_shares::{
        state::{MultState, MultStateMessage},
        OperandShares,
    },
    random::random_invertible::state::InvertibleElement,
};
use anyhow::anyhow;
use basic_types::{Batches, PartyMessage};
use math_lib::modular::{Modular, ModularNumber, SafePrime};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    errors::StateMachineError, sm::StateMachineOutput, state::StateMachineMessage, StateMachine, StateMachineState,
    StateMachineStateExt, StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

/// The states definitions.
pub mod states {
    use crate::{
        multiplication::{
            multiplication_shares::MultStateMachine,
            multiplication_unbounded::offline::state::UnboundedMultPrepareState,
        },
        random::random_invertible::state::InvertibleElement,
    };
    use basic_types::Batches;
    use math_lib::modular::{ModularNumber, SafePrime};
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use state_machine::StateMachine;
    use std::sync::Arc;

    /// We are waiting for the prepare phase to end.
    pub struct WaitingPrepare<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The UNBOUNDED-MULT prepare state machine.
        pub(crate) prepare_state_machine: StateMachine<UnboundedMultPrepareState<T>>,

        /// The secret sharer this protocol is using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The invertible elements generated in the prepare phase.
        pub(crate) invertible_elements: Batches<InvertibleElement<T>>,

        /// The hidden factors that came out of the prepare phase.
        pub(crate) hidden_factors: Batches<ModularNumber<T>>,
    }

    /// We are waiting for the multiplication to end.
    pub struct WaitingMult<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The MULT state machine.
        pub(crate) mult_state_machine: MultStateMachine<T>,

        /// The hidden factors that came out of the prepare phase.
        pub(crate) hidden_factors: Batches<ModularNumber<T>>,

        /// The outputs of the multiplications generated by MULT.
        pub(crate) multiplication_outputs: Vec<ModularNumber<T>>,
    }
}

/// The protocol output
pub enum UnboundedMultStateOutput<T: Modular> {
    /// The protocol was successful.
    Success {
        /// The output of the multiplication.
        outputs: Vec<ModularNumber<T>>,
    },

    /// INV-RAN was aborted.
    InvRanAbort,
}

/// The state of the state machine.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<UnboundedMultStateMessage>",
    output_message = "UnboundedMultStateMessage",
    final_result = "UnboundedMultStateOutput<T>",
    handle_message_fn = "Self::handle_message"
)]
pub enum UnboundedMultState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for the prepare phase. The inner state is boxed because otherwise Clippy complains about
    /// it being too large to be used in an enum variant.
    #[state_machine(submachine = "state.prepare_state_machine", transition_fn = "Self::transition_waiting_prepare")]
    WaitingPrepare(Box<states::WaitingPrepare<T>>),

    /// We are waiting for the multiplication.
    #[state_machine(submachine = "state.mult_state_machine", transition_fn = "Self::transition_waiting_mult")]
    WaitingMult(states::WaitingMult<T>),
}

use UnboundedMultState::*;

impl<T> UnboundedMultState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new state machine state.
    pub fn new(
        shares: Batches<ModularNumber<T>>,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), UnboundedMultPrepareError> {
        let (prepare_state, messages) = UnboundedMultPrepareState::new(shares, secret_sharer.clone())?;

        let state = states::WaitingPrepare {
            prepare_state_machine: StateMachine::new(prepare_state),
            secret_sharer,
            invertible_elements: Batches::default(),
            hidden_factors: Batches::default(),
        };
        let messages = messages.into_iter().map(|message| message.wrap(&UnboundedMultStateMessage::Prepare)).collect();
        Ok((WaitingPrepare(Box::new(state)), messages))
    }

    fn transition_waiting_prepare(state: Box<states::WaitingPrepare<T>>) -> StateMachineStateResult<Self> {
        let operands = Self::build_operands(&state.invertible_elements)?;
        let (mult_state, messages) = MultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create MULT state: {e}"))?;
        let next_state = states::WaitingMult {
            mult_state_machine: StateMachine::new(mult_state),
            hidden_factors: state.hidden_factors,
            multiplication_outputs: Vec::new(),
        };
        let messages = messages.into_iter().map(|message| message.wrap(&UnboundedMultStateMessage::Mult)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingMult(next_state), messages))
    }

    fn transition_waiting_mult(state: states::WaitingMult<T>) -> StateMachineStateResult<Self> {
        let outputs = Self::merge_output(state.hidden_factors, state.multiplication_outputs)?;
        let final_output = UnboundedMultStateOutput::Success { outputs };
        Ok(StateMachineStateOutput::Final(final_output))
    }

    fn build_operands(invertibles: &Batches<InvertibleElement<T>>) -> Result<Vec<OperandShares<T>>, StateMachineError> {
        let mut operands = Vec::new();
        for batch in invertibles.iter() {
            let first = batch.first().ok_or_else(|| anyhow!("no invertible elements found"))?;
            let last = batch.last().ok_or_else(|| anyhow!("no invertible elements found"))?;
            operands.push(OperandShares::single(first.inverse, last.element));
        }
        Ok(operands)
    }

    fn merge_output(
        hidden_factors: Batches<ModularNumber<T>>,
        multiplication_outputs: Vec<ModularNumber<T>>,
    ) -> Result<Vec<ModularNumber<T>>, StateMachineError> {
        let mut outputs = Vec::new();
        for (batch, mut output) in hidden_factors.into_iter().zip(multiplication_outputs.into_iter()) {
            for factor in batch {
                output = output * &factor;
            }
            outputs.push(output);
        }
        Ok(outputs)
    }

    fn handle_message(
        mut state: Self,
        message: PartyMessage<UnboundedMultStateMessage>,
    ) -> StateMachineStateResult<Self> {
        use UnboundedMultStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (Prepare(message), WaitingPrepare(inner)) => {
                match inner.prepare_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(UnboundedMultPrepareStateOutput::Success {
                        invertible_elements,
                        hidden_factors,
                    }) => {
                        inner.invertible_elements = invertible_elements;
                        inner.hidden_factors = hidden_factors;
                        state.try_next()
                    }
                    StateMachineOutput::Final(_) => {
                        Ok(StateMachineStateOutput::Final(UnboundedMultStateOutput::InvRanAbort))
                    }
                    output => state.wrap_message(output, Prepare),
                }
            }
            (Mult(message), WaitingMult(inner)) => {
                match inner.mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(output) => {
                        inner.multiplication_outputs = output;
                        state.try_next()
                    }
                    output => state.wrap_message(output, Mult),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }
}

/// A message for this state machine.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[repr(u8)]
pub enum UnboundedMultStateMessage {
    /// A message for the underlying UNBOUNDED-MULT-PREPARE state machine.
    Prepare(UnboundedMultPrepareStateMessage) = 0,

    /// A message for the underlying MULT state machine.
    Mult(MultStateMessage) = 1,
}

#[allow(clippy::arithmetic_side_effects, clippy::indexing_slicing)]
#[cfg(test)]
mod test {
    use super::*;
    use anyhow::Result;
    use math_lib::modular::U64SafePrime;

    type Prime = U64SafePrime;
    type Sharer = ShamirSecretSharer<Prime>;
    type State = UnboundedMultState<Prime>;

    fn make_secret_sharer() -> Arc<Sharer> {
        let parties = vec![PartyId::from(10), PartyId::from(20)];
        // Note: these parameters are useless, we won't actually use Shamir directly in these tests.
        let secret_sharer = Sharer::new(parties[0].clone(), 1, parties).unwrap();
        Arc::new(secret_sharer)
    }

    #[test]
    fn operand_construction() {
        let invertibles = vec![
            InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(88)),
            InvertibleElement::new(ModularNumber::from_u32(32), ModularNumber::from_u32(55)),
            InvertibleElement::new(ModularNumber::from_u32(13), ModularNumber::from_u32(56)),
        ];
        let operands = State::build_operands(&Batches::single(invertibles)).unwrap();
        assert_eq!(operands.len(), 1);
        assert_eq!(operands[0], OperandShares::single(ModularNumber::from_u32(88), ModularNumber::from_u32(13)));
    }

    #[test]
    fn output_construction() {
        let hidden_factors = Batches::single(vec![ModularNumber::from_u32(5), ModularNumber::from_u32(10)]);
        let multiplication_outputs = vec![ModularNumber::from_u32(101)];
        let outputs = State::merge_output(hidden_factors, multiplication_outputs).unwrap();
        assert_eq!(outputs.len(), 1);
        assert_eq!(outputs[0], ModularNumber::from_u32(5050));
    }

    #[test]
    fn waiting_prepare_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingPrepare {
            prepare_state_machine: StateMachine::new(
                UnboundedMultPrepareState::new(Batches::default(), secret_sharer.clone())?.0,
            ),
            secret_sharer,
            invertible_elements: Batches::single(vec![
                InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(88)),
                InvertibleElement::new(ModularNumber::from_u32(32), ModularNumber::from_u32(55)),
            ]),
            hidden_factors: Batches::single(vec![ModularNumber::from_u32(5)]),
        };

        let state = State::transition_waiting_prepare(Box::new(state))?.into_state()?;
        let inner = state.waiting_mult_state()?;
        assert_eq!(inner.multiplication_outputs.len(), 0);

        Ok(())
    }

    #[test]
    fn waiting_mult_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingMult {
            mult_state_machine: StateMachine::new(MultState::new(vec![], secret_sharer)?.0),
            hidden_factors: Batches::empty(1),
            multiplication_outputs: vec![ModularNumber::from_u32(42)],
        };

        let output = State::transition_waiting_mult(state)?.into_final()?;
        match output {
            UnboundedMultStateOutput::Success { outputs } => {
                assert_eq!(outputs, &[ModularNumber::from_u32(42)]);
                Ok(())
            }
            _ => Err(anyhow!("unexpected final state")),
        }
    }
}
