//! The UNBOUNDED-MULT-PREPARE protocol state machine.

use crate::{
    multiplication::multiplication_shares::{
        state::{MultState, MultStateMessage},
        OperandShares,
    },
    random::random_invertible::state::{
        InvRanError, InvRanState, InvRanStateMessage, InvRanStateOutput, InvertibleElement,
    },
    reveal::state::{RevealMode, RevealState, RevealStateMessage},
};
use anyhow::anyhow;
use basic_types::{Batches, PartyMessage};
use math_lib::modular::{EncodedModularNumber, Modular, ModularNumber, SafePrime};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    sm::StateMachineOutput, state::StateMachineMessage, StateMachine, StateMachineState, StateMachineStateExt,
    StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

/// The states definitions.
pub mod states {
    use crate::{
        multiplication::multiplication_shares::MultStateMachine,
        random::random_invertible::{state::InvertibleElement, InvRanStateMachine},
        reveal::RevealStateMachine,
    };
    use basic_types::Batches;
    use math_lib::{
        fields::PrimeField,
        modular::{ModularNumber, SafePrime},
    };
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// We are waiting for INV-RAN.
    pub struct WaitingInvRan<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The secret sharer this protocol is using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The shares of the secrets being multiplied.
        pub(crate) shares: Batches<ModularNumber<T>>,

        /// The size of each batch.
        pub(crate) batch_sizes: Vec<usize>,

        /// The number of invertibles in each batch. Index i will contain `batch_sizes[i] + 1`.
        pub(crate) invertible_batch_sizes: Vec<usize>,

        /// The INV-RAN state machine.
        pub(crate) inv_ran_state_machine: InvRanStateMachine<T>,

        /// The invertible elements generated by INV-RAN.
        pub(crate) invertible_elements: Batches<InvertibleElement<T>>,
    }

    /// We are waiting for the MULT on the elements.
    pub struct WaitingElementMult<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The secret sharer this protocol is using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The MULT state machine.
        pub(crate) mult_state_machine: MultStateMachine<T>,

        /// The size of each batch.
        pub(crate) batch_sizes: Vec<usize>,

        /// The invertible elements generated in the previous phase.
        pub(crate) invertible_elements: Batches<InvertibleElement<T>>,

        /// The result of the multiplications generated by MULT
        pub(crate) multiplication_outputs: Batches<ModularNumber<T>>,
    }

    /// We are waiting for the MULT on the element inverses.
    pub struct WaitingInverseMult<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The secret sharer this protocol is using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The MULT state machine.
        pub(crate) mult_state_machine: MultStateMachine<T>,

        /// The size of each batch.
        pub(crate) batch_sizes: Vec<usize>,

        /// The invertible elements generated in the first phase.
        pub(crate) invertible_elements: Batches<InvertibleElement<T>>,

        /// The result of the multiplications generated by this phase's MULT.
        pub(crate) multiplication_outputs: Batches<ModularNumber<T>>,
    }

    /// We are waiting for the REVEAL.
    pub struct WaitingReveal<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The reveal state machine.
        pub(crate) reveal_state_machine: RevealStateMachine<PrimeField<T>, ShamirSecretSharer<T>>,

        /// The size of each batch.
        pub(crate) batch_sizes: Vec<usize>,

        /// The invertible elements generated in the first phase.
        pub(crate) invertible_elements: Batches<InvertibleElement<T>>,

        /// The hidden factors generated by REVEAL.
        pub(crate) hidden_factors: Batches<ModularNumber<T>>,
    }
}

/// The output of this state machine.
pub enum UnboundedMultPrepareStateOutput<T: Modular> {
    /// The protocol was successful.
    Success {
        /// The invertible elements generated in the first phase.
        invertible_elements: Batches<InvertibleElement<T>>,

        /// The reconstructed factors.
        hidden_factors: Batches<ModularNumber<T>>,
    },

    /// INV-RAN was aborted.
    InvRanAbort,
}

/// The state of this protocol.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<UnboundedMultPrepareStateMessage>",
    output_message = "UnboundedMultPrepareStateMessage",
    final_result = "UnboundedMultPrepareStateOutput<T>",
    handle_message_fn = "Self::handle_message"
)]
pub enum UnboundedMultPrepareState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for INV-RAN.
    #[state_machine(submachine = "state.inv_ran_state_machine", transition_fn = "Self::transition_waiting_inv_ran")]
    WaitingInvRan(states::WaitingInvRan<T>),

    /// We are waiting for the first MULT.
    #[state_machine(
        completed = "state.mult_state_machine.is_state_completed()",
        transition_fn = "Self::transition_waiting_element_mult"
    )]
    WaitingElementMult(states::WaitingElementMult<T>),

    /// We are waiting for the second MULT.
    #[state_machine(
        completed = "state.mult_state_machine.is_state_completed()",
        transition_fn = "Self::transition_waiting_inverse_mult"
    )]
    WaitingInverseMult(states::WaitingInverseMult<T>),

    /// We are waiting for the REVEAL.
    #[state_machine(
        completed = "state.reveal_state_machine.is_state_completed()",
        transition_fn = "Self::transition_waiting_reveal"
    )]
    WaitingReveal(states::WaitingReveal<T>),
}

use UnboundedMultPrepareState::*;

impl<T> UnboundedMultPrepareState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new state machine state.
    pub fn new(
        shares: Batches<ModularNumber<T>>,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), UnboundedMultPrepareError> {
        let mut invertible_count: usize = 0;
        let mut batch_sizes = Vec::new();
        let mut invertible_batch_sizes = Vec::new();
        for batch in shares.iter() {
            // We need N + 1 invertibles for a batch of N shares.
            let invertibles_for_batch = batch.len().checked_add(1).ok_or(UnboundedMultPrepareError::TooManyShares)?;
            invertible_count =
                invertible_count.checked_add(invertibles_for_batch).ok_or(UnboundedMultPrepareError::TooManyShares)?;
            batch_sizes.push(batch.len());
            invertible_batch_sizes.push(invertibles_for_batch);
        }
        // The error for INV-RAN is basically the same as ours; no need to have two separate enum states
        // to represent the same error (number of shares overflowed usize, which will never happen).
        let (inv_ran_state, messages) = InvRanState::new(invertible_count, secret_sharer.clone())?;

        let state = states::WaitingInvRan {
            secret_sharer,
            shares,
            batch_sizes,
            invertible_batch_sizes,
            inv_ran_state_machine: StateMachine::new(inv_ran_state),
            invertible_elements: Batches::default(),
        };
        let messages =
            messages.into_iter().map(|message| message.wrap(&UnboundedMultPrepareStateMessage::InvRan)).collect();
        Ok((WaitingInvRan(state), messages))
    }

    fn transition_waiting_inv_ran(state: states::WaitingInvRan<T>) -> StateMachineStateResult<Self> {
        let operands = Self::build_element_multiplication_operands(state.shares, &state.invertible_elements);
        let (mult_state, messages) = MultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create MULT state: {e}"))?;
        let next_state = states::WaitingElementMult {
            secret_sharer: state.secret_sharer,
            batch_sizes: state.batch_sizes,
            invertible_elements: state.invertible_elements,
            mult_state_machine: StateMachine::new(mult_state),
            multiplication_outputs: Batches::default(),
        };
        let messages =
            messages.into_iter().map(|message| message.wrap(&UnboundedMultPrepareStateMessage::ElementMult)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingElementMult(next_state), messages))
    }

    fn transition_waiting_element_mult(state: states::WaitingElementMult<T>) -> StateMachineStateResult<Self> {
        let operands =
            Self::build_inverse_multiplication_operands(state.multiplication_outputs, &state.invertible_elements);
        let (mult_state, messages) = MultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create MULT state: {e}"))?;
        let next_state = states::WaitingInverseMult {
            invertible_elements: state.invertible_elements,
            secret_sharer: state.secret_sharer,
            mult_state_machine: StateMachine::new(mult_state),
            batch_sizes: state.batch_sizes,
            multiplication_outputs: Batches::default(),
        };
        let messages =
            messages.into_iter().map(|message| message.wrap(&UnboundedMultPrepareStateMessage::InverseMult)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingInverseMult(next_state), messages))
    }

    fn transition_waiting_inverse_mult(state: states::WaitingInverseMult<T>) -> StateMachineStateResult<Self> {
        let (reveal_state, messages) =
            RevealState::new(RevealMode::new_all(state.multiplication_outputs.flatten()), state.secret_sharer)
                .map_err(|e| anyhow!("failed to create REVEAL state: {e}"))?;
        let next_state = states::WaitingReveal {
            batch_sizes: state.batch_sizes,
            invertible_elements: state.invertible_elements,
            reveal_state_machine: StateMachine::new(reveal_state),
            hidden_factors: Batches::default(),
        };
        let messages =
            messages.into_iter().map(|message| message.wrap(&UnboundedMultPrepareStateMessage::Reveal)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingReveal(next_state), messages))
    }

    fn transition_waiting_reveal(state: states::WaitingReveal<T>) -> StateMachineStateResult<Self> {
        let output = UnboundedMultPrepareStateOutput::Success {
            invertible_elements: state.invertible_elements,
            hidden_factors: state.hidden_factors,
        };
        Ok(StateMachineStateOutput::Final(output))
    }

    fn build_element_multiplication_operands(
        shares: Batches<ModularNumber<T>>,
        invertible_elements: &Batches<InvertibleElement<T>>,
    ) -> Vec<OperandShares<T>> {
        // Create an OperandShares out of the element out of the invertible pair as a left hand side and one of the shares
        // as the right one.
        let mut operands = Vec::new();
        for (shares_batch, invertibles_batch) in shares.into_iter().zip(invertible_elements.iter()) {
            let multipliers = invertibles_batch.iter();
            for (left_invertible, right) in multipliers.zip(shares_batch.into_iter()) {
                let left = left_invertible.element;
                operands.push(OperandShares::single(left, right));
            }
        }
        operands
    }

    fn build_inverse_multiplication_operands(
        element_multiplication_outputs: Batches<ModularNumber<T>>,
        invertible_elements: &Batches<InvertibleElement<T>>,
    ) -> Vec<OperandShares<T>> {
        let mut operands = Vec::new();
        let zipped_elements = element_multiplication_outputs.into_iter().zip(invertible_elements.iter());
        for (shares_batch, invertibles_batch) in zipped_elements {
            let multipliers = invertibles_batch.iter().skip(1);
            for (left, right_invertible) in shares_batch.into_iter().zip(multipliers) {
                let right = right_invertible.inverse;
                operands.push(OperandShares::single(left, right));
            }
        }
        operands
    }

    fn handle_message(
        mut state: Self,
        message: PartyMessage<UnboundedMultPrepareStateMessage>,
    ) -> StateMachineStateResult<Self> {
        use UnboundedMultPrepareStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (InvRan(message), WaitingInvRan(inner)) => {
                match inner.inv_ran_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(InvRanStateOutput::Success { elements }) => {
                        let batches = Batches::from_flattened(elements, &inner.invertible_batch_sizes)
                            .map_err(anyhow::Error::from)?;
                        inner.invertible_elements = batches;
                        state.try_next()
                    }
                    StateMachineOutput::Final(_) => {
                        Ok(StateMachineStateOutput::Final(UnboundedMultPrepareStateOutput::InvRanAbort))
                    }
                    output => state.wrap_message(output, InvRan),
                }
            }
            (ElementMult(message), WaitingElementMult(inner)) => {
                match inner.mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(output) => {
                        let batches =
                            Batches::from_flattened(output, &inner.batch_sizes).map_err(anyhow::Error::from)?;
                        inner.multiplication_outputs = batches;
                        state.try_next()
                    }
                    output => state.wrap_message(output, ElementMult),
                }
            }
            (InverseMult(message), WaitingInverseMult(inner)) => {
                match inner.mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(output) => {
                        let batches =
                            Batches::from_flattened(output, &inner.batch_sizes).map_err(anyhow::Error::from)?;
                        inner.multiplication_outputs = batches;
                        state.try_next()
                    }
                    output => state.wrap_message(output, InverseMult),
                }
            }
            (Reveal(message), WaitingReveal(inner)) => {
                match inner.reveal_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(output) => {
                        let batches =
                            Batches::from_flattened(output, &inner.batch_sizes).map_err(anyhow::Error::from)?;
                        inner.hidden_factors = batches;
                        state.try_next()
                    }
                    output => state.wrap_message(output, Reveal),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }
}

/// A message for this state machine.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[repr(u8)]
pub enum UnboundedMultPrepareStateMessage {
    /// A message for the INV-RAN sub state machine.
    InvRan(InvRanStateMessage) = 0,

    /// A message for the element MULT sub state machine.
    ElementMult(MultStateMessage) = 1,

    /// A message for the inverse MULT sub state machine.
    InverseMult(MultStateMessage) = 2,

    /// A message for the REVEAL sub state machine.
    Reveal(RevealStateMessage<EncodedModularNumber>) = 3,
}

/// An error during the creation of the UNBOUNDED-MULT state.
#[derive(Debug, thiserror::Error)]
pub enum UnboundedMultPrepareError {
    /// Indicates too many shares were requested during the construction of the initial state.
    #[error("too many shares")]
    TooManyShares,

    /// An error during the creation of the INV-RAN state.
    #[error("INV-RAN: {0}")]
    InvRan(#[from] InvRanError),
}

#[allow(clippy::arithmetic_side_effects, clippy::indexing_slicing)]
#[cfg(test)]
mod test {
    use super::*;
    use anyhow::Result;
    use math_lib::modular::U64SafePrime;

    type Prime = U64SafePrime;
    type Sharer = ShamirSecretSharer<Prime>;
    type State = UnboundedMultPrepareState<Prime>;

    // Note: all the invertible elements and multiplications used in this test are chosen at random, so
    // they're not really invertibles nor actual multiplications.

    fn make_secret_sharer() -> Arc<Sharer> {
        let parties = vec![PartyId::from(10), PartyId::from(20)];
        // Note: these parameters are useless, we won't actually use Shamir directly in these tests.
        let secret_sharer = Sharer::new(parties[0].clone(), 1, parties).unwrap();
        Arc::new(secret_sharer)
    }

    #[test]
    fn element_multiplication_operands() {
        let invertibles = vec![
            InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(1337)),
            InvertibleElement::new(ModularNumber::from_u32(10), ModularNumber::from_u32(20)),
            InvertibleElement::new(ModularNumber::from_u32(100), ModularNumber::from_u32(200)),
        ];
        let shares = vec![ModularNumber::ONE, ModularNumber::two()];
        let operands =
            State::build_element_multiplication_operands(Batches::single(shares), &Batches::single(invertibles));
        assert_eq!(operands.len(), 2);
        // The first invertible with the first share, the second with the second.
        assert_eq!(operands[0], OperandShares::single(ModularNumber::from_u32(42), ModularNumber::ONE));
        assert_eq!(operands[1], OperandShares::single(ModularNumber::from_u32(10), ModularNumber::two()));
        assert_eq!(operands.len(), 2);
    }

    #[test]
    fn inverse_multiplication_operands() {
        let invertibles = vec![
            InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(1337)),
            InvertibleElement::new(ModularNumber::from_u32(10), ModularNumber::from_u32(20)),
            InvertibleElement::new(ModularNumber::from_u32(100), ModularNumber::from_u32(200)),
        ];
        let element_mult_output = vec![ModularNumber::from_u32(150), ModularNumber::from_u32(212)];
        let operands = State::build_inverse_multiplication_operands(
            Batches::single(element_mult_output),
            &Batches::single(invertibles),
        );
        assert_eq!(operands.len(), 2);
        assert_eq!(operands[0], OperandShares::single(ModularNumber::from_u32(150), ModularNumber::from_u32(20)));
        assert_eq!(operands[1], OperandShares::single(ModularNumber::from_u32(212), ModularNumber::from_u32(200)));
    }

    #[test]
    fn waiting_invertibles_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingInvRan {
            secret_sharer: secret_sharer.clone(),
            batch_sizes: vec![1],
            invertible_batch_sizes: vec![2],
            shares: Batches::single(vec![ModularNumber::ONE]),
            inv_ran_state_machine: StateMachine::new(InvRanState::new(2, secret_sharer)?.0),
            invertible_elements: Batches::single(vec![
                InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(1337)),
                InvertibleElement::new(ModularNumber::from_u32(10), ModularNumber::from_u32(20)),
            ]),
        };

        let state = State::transition_waiting_inv_ran(state)?.into_state()?;
        let inner = state.waiting_element_mult_state()?;
        assert_eq!(inner.invertible_elements.len(), 1);
        assert_eq!(inner.invertible_elements[0].len(), 2);
        assert_eq!(inner.multiplication_outputs.len(), 0);
        Ok(())
    }

    #[test]
    fn waiting_element_mult_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingElementMult {
            secret_sharer: secret_sharer.clone(),
            batch_sizes: vec![1],
            mult_state_machine: StateMachine::new(MultState::new(vec![], secret_sharer)?.0),
            invertible_elements: Batches::single(vec![
                InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(1337)),
                InvertibleElement::new(ModularNumber::from_u32(10), ModularNumber::from_u32(20)),
            ]),
            multiplication_outputs: Batches::single(vec![ModularNumber::from_u32(150), ModularNumber::from_u32(212)]),
        };

        let state = State::transition_waiting_element_mult(state)?.into_state()?;
        let inner = state.waiting_inverse_mult_state()?;
        assert_eq!(inner.invertible_elements.len(), 1);
        assert_eq!(inner.invertible_elements[0].len(), 2);
        assert_eq!(inner.multiplication_outputs.len(), 0);
        Ok(())
    }

    #[test]
    fn waiting_inverse_mult_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingInverseMult {
            secret_sharer: secret_sharer.clone(),
            mult_state_machine: StateMachine::new(MultState::new(vec![], secret_sharer)?.0),
            batch_sizes: vec![1],
            invertible_elements: Batches::single(vec![
                InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(1337)),
                InvertibleElement::new(ModularNumber::from_u32(10), ModularNumber::from_u32(20)),
            ]),
            multiplication_outputs: Batches::single(vec![ModularNumber::from_u32(150), ModularNumber::from_u32(212)]),
        };

        let (state, messages) = State::transition_waiting_inverse_mult(state)?.into_messages()?;
        let inner = state.waiting_reveal_state()?;
        assert_eq!(inner.invertible_elements.len(), 1);
        assert_eq!(inner.invertible_elements[0].len(), 2);
        assert_eq!(inner.hidden_factors.len(), 0);

        assert_eq!(messages.len(), 1);
        assert!(matches!(messages[0].contents(), UnboundedMultPrepareStateMessage::Reveal(RevealStateMessage { .. })));
        Ok(())
    }

    #[test]
    fn waiting_reveal_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingReveal {
            reveal_state_machine: StateMachine::new(RevealState::new(RevealMode::new_all(vec![]), secret_sharer)?.0),
            batch_sizes: vec![1],
            invertible_elements: Batches::single(vec![
                InvertibleElement::new(ModularNumber::from_u32(42), ModularNumber::from_u32(1337)),
                InvertibleElement::new(ModularNumber::from_u32(10), ModularNumber::from_u32(20)),
            ]),
            hidden_factors: Batches::single(vec![ModularNumber::from_u32(987), ModularNumber::from_u32(678)]),
        };

        match State::transition_waiting_reveal(state)?.into_final()? {
            UnboundedMultPrepareStateOutput::Success { invertible_elements, hidden_factors } => {
                assert_eq!(invertible_elements.len(), 1);
                assert_eq!(invertible_elements[0].len(), 2);
                assert_eq!(hidden_factors.len(), 1);
                assert_eq!(hidden_factors[0].len(), 2);
                Ok(())
            }
            _ => Err(anyhow!("unexpected final state")),
        }
    }
}
