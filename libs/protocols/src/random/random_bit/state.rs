//! The RAN-BIT protocol.

use crate::{
    multiplication::multiplication_public_output::{
        state::{PubMultState, PubMultStateMessage},
        PubOperandShares,
    },
    random::{
        random_bit::BitShare,
        random_integer::state::{RandomIntegerError, RandomIntegerState, RandomIntegerStateMessage, RandomMode},
    },
};
use anyhow::{anyhow, Error};
use basic_types::PartyMessage;
use math_lib::{
    fields::Inv,
    modular::{ModularNumber, SafePrime, Sqrt},
};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    sm::StateMachineOutput, state::StateMachineMessage, StateMachine, StateMachineState, StateMachineStateExt,
    StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

/// The states for this state machine.
pub mod states {
    use crate::{
        multiplication::multiplication_public_output::PubMultStateMachine,
        random::random_integer::RandomIntegerStateMachine,
    };
    use math_lib::modular::{ModularNumber, SafePrime};
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// We are waiting for RAN.
    pub struct WaitingRandomInteger<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The RAN state machine.
        pub(crate) ran_state_machine: RandomIntegerStateMachine<T>,

        /// The secret sharer to be used.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The random output generated by RAN.
        pub(crate) random_shares: Vec<ModularNumber<T>>,
    }

    /// We are waiting for RAN-ZERO.
    pub struct WaitingRandomZeros<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The RAN-ZERO state machine.
        pub(crate) ran_zero_state_machine: RandomIntegerStateMachine<T>,

        /// The secret sharer to be used.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The random output generated by RAN.
        pub(crate) random_shares: Vec<ModularNumber<T>>,

        /// The zeros required for PUB-MULT.
        pub(crate) zeros: Vec<ModularNumber<T>>,
    }

    /// We are waiting for PUB-MULT.
    pub struct WaitingPubMult<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The PUB-MULT state machine.
        pub(crate) pub_mult_state_machine: PubMultStateMachine<T>,

        /// The random output generated by RAN.
        pub(crate) random_shares: Vec<ModularNumber<T>>,

        /// The square of the number behind each random share, as produced by PUB-MULT.
        pub(crate) squares: Vec<ModularNumber<T>>,
    }
}

/// The RAN-BIT state machine state.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<RandomBitStateMessage>",
    output_message = "RandomBitStateMessage",
    final_result = "RandomBitStateOutput<BitShare<T>>",
    handle_message_fn = "Self::handle_message"
)]
pub enum RandomBitState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for RAN.
    #[state_machine(submachine = "state.ran_state_machine", transition_fn = "Self::transition_waiting_ran")]
    WaitingRan(states::WaitingRandomInteger<T>),

    /// We are waiting for RAN-ZERO.
    #[state_machine(submachine = "state.ran_zero_state_machine", transition_fn = "Self::transition_waiting_ran_zero")]
    WaitingRanZero(states::WaitingRandomZeros<T>),

    /// We are waiting for PUB-MULT.
    #[state_machine(submachine = "state.pub_mult_state_machine", transition_fn = "Self::transition_waiting_pub_mult")]
    WaitingPubMult(states::WaitingPubMult<T>),
}

use crate::random::random_bit::RandomBitStateOutput;
use RandomBitState::*;

impl<T> RandomBitState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new RAN-BIT state.
    pub fn new(
        bit_count: usize,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), RandomBitCreateError> {
        let (ran_state, messages) =
            RandomIntegerState::new(RandomMode::RandomOfDegreeT, bit_count, secret_sharer.clone())?;
        let messages = messages.into_iter().map(|message| message.wrap(&RandomBitStateMessage::Ran)).collect();
        let state = states::WaitingRandomInteger {
            secret_sharer,
            ran_state_machine: StateMachine::new(ran_state),
            random_shares: Vec::new(),
        };
        Ok((WaitingRan(state), messages))
    }

    fn transition_waiting_ran(state: states::WaitingRandomInteger<T>) -> StateMachineStateResult<Self> {
        let (ran_zero_state, messages) = RandomIntegerState::new(
            RandomMode::ZerosOfDegree2T,
            state.random_shares.len(),
            state.secret_sharer.clone(),
        )
        .map_err(|e| anyhow!("RAN-BIT failed to create RAN-ZERO state: {e}"))?;
        let next_state = states::WaitingRandomZeros {
            secret_sharer: state.secret_sharer,
            random_shares: state.random_shares,
            ran_zero_state_machine: StateMachine::new(ran_zero_state),
            zeros: Vec::new(),
        };
        let messages = messages.into_iter().map(|message| message.wrap(&RandomBitStateMessage::RanZero)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingRanZero(next_state), messages))
    }

    fn transition_waiting_ran_zero(state: states::WaitingRandomZeros<T>) -> StateMachineStateResult<Self> {
        let operands = state
            .random_shares
            .iter()
            .zip(state.zeros.iter())
            .map(|(share, zero)| PubOperandShares::single(*share, *share, *zero))
            .collect();
        let (pub_mult_state, messages) = PubMultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("RAN-BIT failed to create PUB-MULT: {e}"))?;
        let next_state = states::WaitingPubMult {
            pub_mult_state_machine: StateMachine::new(pub_mult_state),
            random_shares: state.random_shares,
            squares: Vec::new(),
        };
        let messages = messages.into_iter().map(|message| message.wrap(&RandomBitStateMessage::PubMult)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingPubMult(next_state), messages))
    }

    fn transition_waiting_pub_mult(state: states::WaitingPubMult<T>) -> StateMachineStateResult<Self> {
        let output = Self::compute_output(state.squares, state.random_shares)
            .map_err(|e| anyhow!("RAN-BIT failed to compute final output: {e}"))?;
        Ok(StateMachineStateOutput::Final(output))
    }

    fn handle_message(mut state: Self, message: PartyMessage<RandomBitStateMessage>) -> StateMachineStateResult<Self> {
        use RandomBitStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (Ran(message), WaitingRan(inner)) => {
                match inner.ran_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(shares) => {
                        inner.random_shares = shares;
                        state.try_next()
                    }
                    output => state.wrap_message(output, RandomBitStateMessage::Ran),
                }
            }
            (RanZero(message), WaitingRanZero(inner)) => {
                match inner.ran_zero_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.zeros = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, RandomBitStateMessage::RanZero),
                }
            }
            (PubMult(message), WaitingPubMult(inner)) => {
                match inner.pub_mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(shares) => {
                        inner.squares = shares;
                        state.try_next()
                    }
                    output => state.wrap_message(output, RandomBitStateMessage::PubMult),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }

    fn compute_output(
        squares: Vec<ModularNumber<T>>,
        random_shares: Vec<ModularNumber<T>>,
    ) -> Result<RandomBitStateOutput<BitShare<T>>, Error> {
        if squares.iter().any(|square| square.is_zero()) {
            return Ok(RandomBitStateOutput::Abort);
        }
        let two_inverse = ModularNumber::two().inv()?;
        let one = ModularNumber::ONE;
        let mut shares = Vec::new();

        for (share, square) in random_shares.into_iter().zip(squares.into_iter()) {
            let square_root = square.sqrt()?;
            let bit_share = square_root.inv()?;
            let bit_share = bit_share * &share + &one;
            let bit_share = bit_share * &two_inverse;
            shares.push(BitShare::from(bit_share));
        }

        Ok(RandomBitStateOutput::Success { shares })
    }
}

/// A message for the RAN-BIT protocol.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum RandomBitStateMessage {
    /// A message for the RAN protocol state machine.
    Ran(RandomIntegerStateMessage) = 0,

    /// A message for the RAN-ZERO protocol state machine.
    RanZero(RandomIntegerStateMessage) = 1,

    /// A message for the PUB-MULT protocol state machine.
    PubMult(PubMultStateMessage) = 2,
}

/// An error during the creation of `RanBitState`.
#[derive(Debug, thiserror::Error)]
#[error("RAN-BIT create failed: {0}")]
pub struct RandomBitCreateError(#[from] RandomIntegerError);

#[cfg(test)]
mod test {
    use super::*;
    use math_lib::modular::U64SafePrime;

    type State = RandomBitState<U64SafePrime>;

    // We only test this specific failure case. The happy path is tested in an end-to-end test in
    // test.rs.
    #[test]
    fn output_computation() {
        let squares = vec![ModularNumber::ZERO, ModularNumber::from_u32(49)];
        let shares = vec![ModularNumber::from_u32(100), ModularNumber::from_u32(200)];
        let result = State::compute_output(squares, shares).expect("compute output failed");
        assert!(matches!(result, RandomBitStateOutput::Abort));
    }
}
