//! The INV-RAN protocol state machine.

use crate::{
    multiplication::multiplication_shares::{
        state::{MultState, MultStateMessage},
        OperandShares,
    },
    random::random_integer::state::{RandomIntegerError, RandomIntegerState, RandomIntegerStateMessage, RandomMode},
    reveal::state::{RevealMode, RevealState, RevealStateMessage},
};
use anyhow::anyhow;
use basic_types::PartyMessage;
use itertools::Itertools;
use math_lib::modular::{EncodedModularNumber, Modular, ModularInverse, ModularNumber, SafePrime};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    errors::StateMachineError, sm::StateMachineOutput, state::StateMachineMessage, StateMachine, StateMachineState,
    StateMachineStateExt, StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

/// The states definitions.
pub mod states {
    use crate::{
        multiplication::multiplication_shares::{MultStateMachine, OperandShares},
        random::random_integer::RandomIntegerStateMachine,
        reveal::RevealStateMachine,
    };
    use math_lib::{
        fields::PrimeField,
        modular::{ModularNumber, SafePrime},
    };
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// We are waiting for RAN.
    pub struct WaitingRan<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The RAN state machine.
        pub(crate) ran_state_machine: RandomIntegerStateMachine<T>,

        /// The secret sharer this protocol is using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The operand shares that were generated as output of RAN.
        pub(crate) operand_shares: Vec<OperandShares<T>>,
    }

    /// We are waiting for MULT.
    pub struct WaitingMult<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The MULT state machine.
        pub(crate) mult_state_machine: MultStateMachine<T>,

        /// The operands created in the first phase.
        pub(crate) operand_shares: Vec<OperandShares<T>>,

        /// The secret sharer this protocol is using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The multiplication output generated by MULT.
        pub(crate) multiplication_output: Vec<ModularNumber<T>>,
    }

    /// We are waiting for MULT.
    pub struct WaitingReveal<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The REVEAL state machine.
        pub(crate) reveal_state_machine: RevealStateMachine<PrimeField<T>, ShamirSecretSharer<T>>,

        /// The operands created in the first phase.
        pub(crate) operand_shares: Vec<OperandShares<T>>,

        /// The output of REVEAL.
        pub(crate) reveal_output: Vec<ModularNumber<T>>,
    }
}

/// The state machine output.
pub enum InvRanStateOutput<T: Modular> {
    /// The protocol was successful.
    Success {
        /// The generated invertible elements.
        elements: Vec<InvertibleElement<T>>,
    },

    /// RAN was aborted.
    RanAbort,

    /// The protocol was aborted
    Abort,
}

/// The output element and its inverse.
#[derive(Clone)]
pub struct InvertibleElement<T: Modular> {
    /// A share of the element.
    pub element: ModularNumber<T>,

    /// A share of the element's inverse.
    pub inverse: ModularNumber<T>,
}

impl<T: Modular> InvertibleElement<T> {
    /// Construct a new instance.
    pub fn new(element: ModularNumber<T>, inverse: ModularNumber<T>) -> Self {
        Self { element, inverse }
    }
}

/// The INV-RAN protocol state machine.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<InvRanStateMessage>",
    output_message = "InvRanStateMessage",
    final_result = "InvRanStateOutput<T>",
    handle_message_fn = "Self::handle_message"
)]
pub enum InvRanState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for RAN.
    #[state_machine(submachine = "state.ran_state_machine", transition_fn = "Self::transition_waiting_ran")]
    WaitingRan(states::WaitingRan<T>),

    /// We are waiting for MULT.
    #[state_machine(submachine = "state.mult_state_machine", transition_fn = "Self::transition_waiting_mult")]
    WaitingMult(states::WaitingMult<T>),

    /// We are waiting for REVEAL.
    #[state_machine(submachine = "state.reveal_state_machine", transition_fn = "Self::transition_waiting_reveal")]
    WaitingReveal(states::WaitingReveal<T>),
}

use InvRanState::*;

impl<T> InvRanState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new state machine.
    pub fn new(
        element_count: usize,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), InvRanError> {
        // We need 2 elements per output element: the output element and the operand used during the
        // INV-RAN multiplication
        let random_elements_count = element_count.checked_mul(2).ok_or(InvRanError::TooManyElements)?;
        let (ran_state, messages) =
            RandomIntegerState::new(RandomMode::RandomOfDegreeT, random_elements_count, secret_sharer.clone())?;
        let state: states::WaitingRan<T> = states::WaitingRan {
            ran_state_machine: StateMachine::new(ran_state),
            secret_sharer,
            operand_shares: Vec::new(),
        };
        // Propagate the RAN messages up
        let messages = messages.into_iter().map(|message| message.wrap(&InvRanStateMessage::Ran)).collect();
        Ok((WaitingRan(state), messages))
    }

    fn transition_waiting_ran(state: states::WaitingRan<T>) -> StateMachineStateResult<Self> {
        let (mult_state, messages) = MultState::new(state.operand_shares.clone(), state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create mult: {e}"))?;
        let mult_state_machine = StateMachine::new(mult_state);
        let next_state = states::WaitingMult {
            mult_state_machine,
            secret_sharer: state.secret_sharer,
            operand_shares: state.operand_shares,
            multiplication_output: Vec::new(),
        };
        let messages = messages.into_iter().map(|message| message.wrap(&InvRanStateMessage::Mult)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingMult(next_state), messages))
    }

    fn transition_waiting_mult(state: states::WaitingMult<T>) -> StateMachineStateResult<Self> {
        let (reveal_state, messages) =
            RevealState::new(RevealMode::new_all(state.multiplication_output), state.secret_sharer)
                .map_err(|e| anyhow!("failed to create REVEAL state: {e}"))?;
        let reveal_state_machine = StateMachine::new(reveal_state);
        let next_state = states::WaitingReveal {
            reveal_state_machine,
            operand_shares: state.operand_shares,
            reveal_output: Vec::new(),
        };
        let messages = messages.into_iter().map(|message| message.wrap(&InvRanStateMessage::Reveal)).collect();
        Ok(StateMachineStateOutput::Messages(WaitingReveal(next_state), messages))
    }

    fn transition_waiting_reveal(state: states::WaitingReveal<T>) -> StateMachineStateResult<Self> {
        let result = Self::compute_final_result(state.operand_shares, state.reveal_output)?;
        Ok(StateMachineStateOutput::Final(result))
    }

    fn split_shares(
        shares: impl IntoIterator<Item = ModularNumber<T>>,
    ) -> Result<Vec<OperandShares<T>>, StateMachineError> {
        let mut operands = Vec::new();
        for mut chunk in &shares.into_iter().chunks(2) {
            let (left, right) = match (chunk.next(), chunk.next()) {
                (Some(left), Some(right)) => Ok((left, right)),
                _ => Err(anyhow!("unexpected number of shares")),
            }?;
            let operand_shares = OperandShares::single(left, right);
            operands.push(operand_shares);
        }
        Ok(operands)
    }

    fn compute_final_result(
        operand_shares: Vec<OperandShares<T>>,
        reveal_output: Vec<ModularNumber<T>>,
    ) -> Result<InvRanStateOutput<T>, StateMachineError> {
        let mut elements = Vec::new();
        // Take the share of the operands and their product and compute the inverse.
        for (operands, product) in operand_shares.into_iter().zip(reveal_output.into_iter()) {
            if product.is_zero() {
                return Ok(InvRanStateOutput::Abort);
            }
            let mut inverse = product.inverse();
            for right in operands.right.iter() {
                inverse = inverse * right;
            }
            let mut left = ModularNumber::ONE;
            for l in operands.left.iter() {
                left = left * l;
            }
            let invertible_element = InvertibleElement::new(left, inverse);
            elements.push(invertible_element);
        }
        Ok(InvRanStateOutput::Success { elements })
    }

    fn handle_message(
        mut state: Self,
        message: <Self as StateMachineState>::InputMessage,
    ) -> StateMachineStateResult<Self> {
        use InvRanStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (Ran(message), WaitingRan(inner)) => {
                match inner.ran_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(shares) => {
                        let shares = Self::split_shares(shares)?;
                        inner.operand_shares = shares;
                        state.try_next()
                    }
                    output => state.wrap_message(output, InvRanStateMessage::Ran),
                }
            }
            (Mult(message), WaitingMult(inner)) => {
                match inner.mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(output) => {
                        inner.multiplication_output = output;
                        state.try_next()
                    }
                    output => state.wrap_message(output, InvRanStateMessage::Mult),
                }
            }
            (Reveal(message), WaitingReveal(inner)) => {
                match inner.reveal_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(secrets) => {
                        inner.reveal_output = secrets;
                        state.try_next()
                    }
                    output => state.wrap_message(output, InvRanStateMessage::Reveal),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }
}

/// An error during the INV-RAN state creation.
#[derive(Debug, thiserror::Error)]
pub enum InvRanError {
    /// An error propagated from the initial RAN state construction.
    #[error(transparent)]
    Ran(#[from] RandomIntegerError),

    /// Indicates too many elements were required out of a `InvRan` instantiation.
    #[error("too many elements")]
    TooManyElements,
}

/// A message for this state machine.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum InvRanStateMessage {
    /// A message for the underlying RAN state machine.
    Ran(RandomIntegerStateMessage) = 0,

    /// A message for the underlying MULT state machine.
    Mult(MultStateMessage) = 1,

    /// A message for the underlying Reveal state machine.
    Reveal(RevealStateMessage<EncodedModularNumber>) = 2,
}

#[allow(clippy::arithmetic_side_effects, clippy::indexing_slicing)]
#[cfg(test)]
mod test {
    use super::*;
    use anyhow::Result;
    use math_lib::modular::U64SafePrime;

    type Prime = U64SafePrime;
    type Sharer = ShamirSecretSharer<Prime>;
    type State = InvRanState<Prime>;

    fn make_secret_sharer() -> Arc<Sharer> {
        // Note: these parameters are useless, we won't actually use Shamir directly in these tests.
        let parties = vec![PartyId::from(10), PartyId::from(20)];
        let secret_sharer = Sharer::new(parties[0].clone(), 1, parties).unwrap();
        Arc::new(secret_sharer)
    }

    #[test]
    fn share_splitting() {
        let shares = vec![
            ModularNumber::from_u32(11),
            ModularNumber::from_u32(22),
            ModularNumber::from_u32(33),
            ModularNumber::from_u32(44),
        ];
        let shares = State::split_shares(shares).unwrap();
        assert_eq!(shares.len(), 2);
        assert_eq!(shares[0].left[0], ModularNumber::from_u32(11));
        assert_eq!(shares[0].right[0], ModularNumber::from_u32(22));
        assert_eq!(shares[1].left[0], ModularNumber::from_u32(33));
        assert_eq!(shares[1].right[0], ModularNumber::from_u32(44));
    }

    #[test]
    fn share_splitting_odd_number() {
        let shares = vec![ModularNumber::from_u32(11), ModularNumber::from_u32(22), ModularNumber::from_u32(33)];
        assert!(State::split_shares(shares).is_err());
    }

    #[test]
    fn waiting_shares_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingRan {
            ran_state_machine: StateMachine::new(
                RandomIntegerState::new(RandomMode::RandomOfDegreeT, 1, secret_sharer.clone())?.0,
            ),
            secret_sharer,
            operand_shares: vec![
                OperandShares::single(ModularNumber::from_u32(10), ModularNumber::from_u32(15)),
                OperandShares::single(ModularNumber::from_u32(42), ModularNumber::from_u32(76)),
            ],
        };

        let state = State::transition_waiting_ran(state)?.into_state()?;
        let inner = state.waiting_mult_state()?;
        assert_eq!(inner.operand_shares.len(), 2);
        assert_eq!(inner.multiplication_output.len(), 0);

        Ok(())
    }

    #[test]
    fn waiting_multiplication_transition() -> Result<()> {
        let secret_sharer = make_secret_sharer();
        let state = states::WaitingMult {
            mult_state_machine: StateMachine::new(MultState::new(Vec::new(), secret_sharer.clone())?.0),
            operand_shares: vec![
                OperandShares::single(ModularNumber::from_u32(10), ModularNumber::from_u32(15)),
                OperandShares::single(ModularNumber::from_u32(42), ModularNumber::from_u32(76)),
            ],
            secret_sharer,
            multiplication_output: vec![ModularNumber::from_u32(150), ModularNumber::from_u32(3192)],
        };

        let state = State::transition_waiting_mult(state)?.into_state()?;
        let inner = state.waiting_reveal_state()?;
        assert_eq!(inner.operand_shares.len(), 2);
        assert_eq!(inner.reveal_output.len(), 0);

        Ok(())
    }

    #[test]
    fn waiting_reveal_transition() -> Result<()> {
        let state = states::WaitingReveal {
            reveal_state_machine: StateMachine::new(
                RevealState::new(RevealMode::new_all(vec![]), make_secret_sharer())?.0,
            ),
            operand_shares: vec![
                OperandShares::single(ModularNumber::ONE, ModularNumber::two()),
                OperandShares::single(ModularNumber::from_u32(3), ModularNumber::from_u32(4)),
            ],
            reveal_output: vec![ModularNumber::from_u32(5), ModularNumber::from_u32(6)],
        };

        assert!(State::transition_waiting_reveal(state)?.into_final().is_ok());
        Ok(())
    }

    #[test]
    fn protocol_abort() -> Result<()> {
        let state = states::WaitingReveal {
            reveal_state_machine: StateMachine::new(
                RevealState::new(RevealMode::new_all(vec![]), make_secret_sharer())?.0,
            ),
            operand_shares: vec![OperandShares::single(ModularNumber::from_u32(10), ModularNumber::from_u32(15))],
            reveal_output: vec![ModularNumber::ZERO],
        };

        let output = State::transition_waiting_reveal(state)?.into_final()?;
        assert!(matches!(output, InvRanStateOutput::Abort));
        Ok(())
    }

    #[test]
    fn aborts_on_reveal_zero() {
        let operand_shares = vec![OperandShares::single(ModularNumber::from_u32(3), ModularNumber::from_u32(15))];
        let reveal_output = vec![ModularNumber::ZERO];
        let output = State::compute_final_result(operand_shares, reveal_output).unwrap();
        assert!(matches!(output, InvRanStateOutput::Abort));
    }

    #[test]
    fn no_abort_if_right_operand_is_zero() {
        let operand_shares = vec![OperandShares::single(ModularNumber::from_u32(3), ModularNumber::ZERO)];
        let reveal_output = vec![ModularNumber::from_u32(5)];
        let output = State::compute_final_result(operand_shares, reveal_output).unwrap();
        assert!(matches!(output, InvRanStateOutput::Success { .. }));
    }

    #[test]
    fn final_result_computation() -> Result<()> {
        let operand_shares = vec![
            OperandShares::single(ModularNumber::from_u32(10), ModularNumber::from_u32(15)),
            OperandShares::single(ModularNumber::from_u32(42), ModularNumber::from_u32(76)),
        ];
        let reveal_output = vec![ModularNumber::from_u32(150), ModularNumber::from_u32(3192)];
        let output = State::compute_final_result(operand_shares, reveal_output).unwrap();
        let elements = match output {
            InvRanStateOutput::Success { elements } => elements,
            _ => return Err(anyhow!("protocol was aborted")),
        };

        assert_eq!(elements.len(), 2);
        assert_eq!(elements[0].element, ModularNumber::from_u32(10));
        assert!(elements[0].inverse.is_inverse(&elements[0].element));
        assert_eq!(elements[1].element, ModularNumber::from_u32(42));
        assert!(elements[1].inverse.is_inverse(&elements[1].element));
        Ok(())
    }
}
