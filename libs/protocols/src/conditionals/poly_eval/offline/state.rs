//! Preprocessing for Evaluate Polynomial State Machine
//!
//! This is the Evaluate Polynomial functionality. It is used to obtain evaluate privately a polynomial.

use anyhow::anyhow;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

use basic_types::PartyMessage;

use state_machine::{
    errors::StateMachineError, sm::StateMachineOutput, state::StateMachineMessage, StateMachine, StateMachineState,
    StateMachineStateExt, StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;

use math_lib::modular::{ModularNumber, SafePrime};

use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};

use crate::random::random_invertible::state::{
    InvRanError, InvRanState, InvRanStateMessage, InvRanStateOutput, InvertibleElement,
};

use crate::multiplication::multiplication_shares::{
    state::{MultState, MultStateMessage},
    OperandShares,
};

use super::output::{PrepPolyEvalShares, PrepPolyEvalStateOutput};
use crate::random::random_integer::state::{RandomIntegerState, RandomIntegerStateMessage, RandomMode};

/// The protocol states.
pub mod states {
    use crate::{
        multiplication::multiplication_shares::MultStateMachine,
        random::{
            random_integer::RandomIntegerStateMachine,
            random_invertible::{state::InvertibleElement, InvRanStateMachine},
        },
    };
    use math_lib::modular::{ModularNumber, SafePrime};
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// Waiting for a share of a random number and its inverse
    pub struct WaitingInvRan<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The secret sharer
        pub secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The polynomial degree to evaluate
        pub(crate) poly_eval_degree: u64,

        /// The INV-RAN state machine
        pub(crate) inv_ran_state_machine: InvRanStateMachine<T>,

        /// The invertible elements generated by INV-RAN.
        pub(crate) invertible_elements: Vec<InvertibleElement<T>>,
    }

    /// We are waiting for MULT.
    pub struct WaitingMult<T: SafePrime>
    where
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The secret sharer to be used.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The polynomial degree to evaluate
        pub(crate) poly_eval_degree: u64,

        /// The invertible numbers.
        pub(crate) invertible_numbers: Vec<ModularNumber<T>>,

        /// The powers of the invertible numbers.
        pub(crate) powers: Vec<Vec<ModularNumber<T>>>,

        /// The MULT state machine.
        pub(crate) mult_state_machine: MultStateMachine<T>,

        /// The id to differentiate between rounds.
        pub(crate) round_id: u32,
    }

    /// We are waiting for RAN ZERO 2T.
    pub struct WaitingRanZero<T: SafePrime>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The invertible numbers.
        pub(crate) invertible_numbers: Vec<ModularNumber<T>>,

        /// The powers of the invertible numbers.
        pub(crate) powers: Vec<Vec<ModularNumber<T>>>,

        /// The powers of the invertible numbers.
        pub(crate) zero_shares: Vec<ModularNumber<T>>,

        /// The MULT state machine.
        pub(crate) ran_zero_state_machine: RandomIntegerStateMachine<T>,
    }
}

/// The Prep POLY EVAL protocol state.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<PrepPolyEvalStateMessage>",
    output_message = "PrepPolyEvalStateMessage",
    final_result = "PrepPolyEvalStateOutput<PrepPolyEvalShares<T>>",
    handle_message_fn = "Self::handle_message"
)]
pub enum PrepPolyEvalState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for the preprocessing material.
    #[state_machine(submachine = "state.inv_ran_state_machine", transition_fn = "Self::transition_waiting_inv_ran")]
    WaitingInvRan(states::WaitingInvRan<T>),
    /// We are waiting for MULT.
    #[state_machine(submachine = "state.mult_state_machine", transition_fn = "Self::transition_waiting_mult")]
    WaitingMult(states::WaitingMult<T>),
    /// We are waiting for RAN-ZERO.
    #[state_machine(submachine = "state.ran_zero_state_machine", transition_fn = "Self::transition_waiting_ran_zero")]
    WaitingRanZero(states::WaitingRanZero<T>),
}

use PrepPolyEvalState::*;

impl<T> PrepPolyEvalState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new Prep POLY EVAL state.
    pub fn new(
        element_count: usize,
        poly_eval_degree: u64,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), PrepPolyEvalError> {
        //  Call INV-RAN protocol
        // The error for INV-RAN is basically the same as ours; no need to have two separate enum states
        // to represent the same error (number of shares overflowed usize, which will never happen).
        let (inv_ran_state, messages) = InvRanState::new(element_count, secret_sharer.clone())?;

        let state = states::WaitingInvRan {
            secret_sharer,
            poly_eval_degree,
            inv_ran_state_machine: StateMachine::new(inv_ran_state),
            invertible_elements: Vec::new(),
        };

        let messages = messages.into_iter().map(|message| message.wrap(&PrepPolyEvalStateMessage::InvRan)).collect();
        Ok((WaitingInvRan(state), messages))
    }

    fn transition_waiting_inv_ran(state: states::WaitingInvRan<T>) -> StateMachineStateResult<Self> {
        let (invertible_numbers, powers): (Vec<ModularNumber<T>>, Vec<Vec<ModularNumber<T>>>) = state
            .invertible_elements
            .into_iter()
            .map(|invertible_element| {
                let InvertibleElement { element, inverse } = invertible_element;
                let element_powers = vec![ModularNumber::ONE, element];
                (inverse, element_powers)
            })
            .unzip();

        let elements: Vec<ModularNumber<T>> = powers.iter().filter_map(|v| v.last().cloned()).collect();
        let operands = elements.into_iter().map(|v| OperandShares::single(v, v)).collect();

        let (mult_state, messages) = MultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create MULT state: {e}"))?;

        let round_id = 2; // We have already included 1 and the element itself, so we start at 2.
        let next_state = states::WaitingMult {
            secret_sharer: state.secret_sharer,
            poly_eval_degree: state.poly_eval_degree,
            invertible_numbers,
            powers,
            mult_state_machine: StateMachine::new(mult_state),
            round_id,
        };
        let messages = messages
            .into_iter()
            .map(|message| message.wrap(&|message| PrepPolyEvalStateMessage::Mult(message, round_id)))
            .collect();
        Ok(StateMachineStateOutput::Messages(WaitingMult(next_state), messages))
        //
    }

    fn transition_waiting_mult(state: states::WaitingMult<T>) -> StateMachineStateResult<Self> {
        // If we reach the maximum numbre of rounds, we finish.
        if u64::from(state.round_id) >= state.poly_eval_degree {
            // Call the RAN Protocol
            let zero_element_count = state.invertible_numbers.len();
            let (ran_zero_state, messages) =
                RandomIntegerState::new(RandomMode::ZerosOfDegree2T, zero_element_count, state.secret_sharer.clone())
                    .map_err(|e| anyhow!("failed to create RAN-ZERO state: {e}"))?;
            let messages =
                messages.into_iter().map(|message| message.wrap(&PrepPolyEvalStateMessage::RanZero)).collect();
            let next_state = states::WaitingRanZero {
                invertible_numbers: state.invertible_numbers,
                powers: state.powers,
                ran_zero_state_machine: StateMachine::new(ran_zero_state),
                zero_shares: Vec::new(),
            };

            return Ok(StateMachineStateOutput::Messages(WaitingRanZero(next_state), messages));
        }
        // Every iteration we pop the result of one multiplication on the handle message.
        // We compute the next iteration of operands, and go for the computation.
        // There is one powers array per element count
        let operands: Vec<OperandShares<T>> = state
            .powers
            .iter()
            .filter_map(|v| {
                if let Some(left) = v.last() {
                    v.get(1).map(|right| OperandShares::single(*left, *right))
                } else {
                    None
                } // It should never get here -> Error is checked after
            })
            .collect();

        if operands.len() != state.powers.len() {
            return Err(StateMachineError::UnexpectedError(anyhow!(
                "operands and powers have different lengths, there was an error obtaining the operands".to_string()
            )));
        }

        // We launch the next iteration of multiplications
        let (mult_state, messages) = MultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create MULT state: {e}"))?;

        let round_id = state.round_id.checked_add(1).ok_or_else(|| anyhow!("too many rounds"))?;
        let next_state = states::WaitingMult {
            secret_sharer: state.secret_sharer,
            poly_eval_degree: state.poly_eval_degree,
            invertible_numbers: state.invertible_numbers,
            powers: state.powers,
            mult_state_machine: StateMachine::new(mult_state),
            round_id,
        };
        let messages = messages
            .into_iter()
            .map(|message| message.wrap(&|message| PrepPolyEvalStateMessage::Mult(message, round_id)))
            .collect();
        Ok(StateMachineStateOutput::Messages(WaitingMult(next_state), messages))
    }

    fn transition_waiting_ran_zero(state: states::WaitingRanZero<T>) -> StateMachineStateResult<Self> {
        let mut outputs = Vec::<PrepPolyEvalShares<T>>::with_capacity(state.invertible_numbers.len());
        for ((inv_num, power), zero_share) in
            state.invertible_numbers.into_iter().zip(state.powers.into_iter()).zip(state.zero_shares.into_iter())
        {
            let output = PrepPolyEvalShares { invertible_number: inv_num, powers: power, zero_share };
            outputs.push(output);
        }
        let output = PrepPolyEvalStateOutput::Success { outputs };
        Ok(StateMachineStateOutput::Final(output))
    }
    fn handle_message(
        mut state: Self,
        message: PartyMessage<PrepPolyEvalStateMessage>,
    ) -> StateMachineStateResult<Self> {
        use PrepPolyEvalStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (InvRan(message), WaitingInvRan(inner)) => {
                match inner.inv_ran_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(InvRanStateOutput::Success { elements }) => {
                        inner.invertible_elements = elements;
                        state.try_next()
                    }
                    StateMachineOutput::Final(_) => {
                        Ok(StateMachineStateOutput::Final(PrepPolyEvalStateOutput::InvRanAbort))
                    }
                    output => state.wrap_message(output, InvRan),
                }
            }
            (Mult(message, round_id), WaitingMult(inner)) if inner.round_id == round_id => {
                // Checking that we're in the same round.
                match inner.mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(outputs) => {
                        // We add a new power to the list of powers
                        for (powers, output) in inner.powers.iter_mut().zip(outputs) {
                            powers.push(output);
                        }
                        state.try_next()
                    }
                    output => state.wrap_message(output, |message| Mult(message, round_id)),
                }
            }
            (RanZero(message), WaitingRanZero(inner)) => {
                match inner.ran_zero_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.zero_shares = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, PrepPolyEvalStateMessage::RanZero),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }
}

/// A message for the Prep POLY EVAL protocol.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum PrepPolyEvalStateMessage {
    /// A message for the INV-RAN sub state machine.
    InvRan(InvRanStateMessage) = 0,
    /// A message for the underlying MULT state machine.
    Mult(MultStateMessage, u32) = 1,
    /// A message for the RAN-ZERO state machine.
    RanZero(RandomIntegerStateMessage) = 2,
}

/// An error during the creation of the Prep POLY EVAL state.
#[derive(Debug, thiserror::Error)]
pub enum PrepPolyEvalError {
    /// An error during the creation of the INV-RAN state.
    #[error("INV-RAN: {0}")]
    InvRan(#[from] InvRanError),
}
