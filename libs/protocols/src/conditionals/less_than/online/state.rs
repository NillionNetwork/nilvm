//! The COMPARE protocol state machine.

use crate::{
    conditionals::less_than::offline::PrepCompareShares,
    multiplication::multiplication_public_output::{
        state::{PubMultState, PubMultStateMessage},
        PubOperandShares,
    },
    random::{
        random_bit::{BitShare, BitShareError},
        random_quaternary::QuaternaryShares,
    },
    reveal::state::{PartySecretMismatch, RevealMode, RevealState, RevealStateMessage},
};
use anyhow::{anyhow, Error};
use basic_types::{Batches, PartyId, PartyMessage};
use math_lib::{
    errors::DivByZero,
    modular::{AsBits, EncodedModularNumber, Modular, ModularNumber, SafePrime},
};
use serde::{Deserialize, Serialize};
use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
use state_machine::{
    sm::StateMachineOutput, state::StateMachineMessage, StateMachine, StateMachineState, StateMachineStateExt,
    StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

/// The states of the protocol.
pub mod states {
    use crate::{
        conditionals::less_than::offline::PrepCompareShares,
        multiplication::multiplication_public_output::PubMultStateMachine, reveal::RevealStateMachine,
    };
    use basic_types::Batches;
    use math_lib::{
        fields::PrimeField,
        modular::{ModularNumber, SafePrime},
    };
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};
    use std::sync::Arc;

    /// We are waiting for the masked comparand REVEAL.
    pub struct WaitingMaskedComparandsReveal<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The REVEAL state machine.
        pub(crate) reveal_state_machine: RevealStateMachine<PrimeField<T>, ShamirSecretSharer<T>>,

        /// The secret sharer we're using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The shares previously generated by PREP-COMPARE.
        pub(crate) prep_elements: Vec<PrepCompareShares<T>>,

        /// The revealed comparands.
        pub(crate) comparands: Vec<ModularNumber<T>>,
    }

    /// We are waiting for the prefix factor PUB-MULT.
    pub struct WaitingPubMult<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The PUB-MULT state machine.
        pub(crate) pub_mult_state_machine: PubMultStateMachine<T>,

        /// The secret sharer we're using.
        pub(crate) secret_sharer: Arc<ShamirSecretSharer<T>>,

        /// The shares previously generated by PREP-COMPARE.
        pub(crate) prep_elements: Vec<PrepCompareShares<T>>,

        /// The size of each batch.
        pub(crate) batch_size: usize,

        /// The revealed operands.
        pub(crate) comparands: Vec<ModularNumber<T>>,

        /// The revealed prefix factors.
        pub(crate) prefix_factors: Batches<ModularNumber<T>>,
    }

    /// We are waiting for the masked filter PUB-MULT.
    pub struct WaitingPubInnerProduct<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The PUB-MULT state machine.
        pub(crate) pub_mult_state_machine: PubMultStateMachine<T>,

        /// The shares previously generated by PREP-COMPARE.
        pub(crate) prep_elements: Vec<PrepCompareShares<T>>,

        /// The revealed operands.
        pub(crate) comparands: Vec<ModularNumber<T>>,

        /// The revealed masked filter.
        pub(crate) filters: Vec<ModularNumber<T>>,
    }
}

/// The two comparands that need to be compared.
#[derive(Clone)]
pub struct Comparands<T: Modular> {
    /// The first comparand.
    pub left: ModularNumber<T>,

    /// The second comparand.
    pub right: ModularNumber<T>,

    /// The preprocessing elements needed for this comparison.
    pub prep_elements: PrepCompareShares<T>,
}

/// The COMPARE protocol state.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<CompareStateMessage>",
    output_message = "CompareStateMessage",
    final_result = "Vec<ModularNumber<T>>",
    handle_message_fn = "Self::handle_message"
)]
pub enum CompareState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for the masked comparand REVEAL.
    #[state_machine(
        submachine = "state.reveal_state_machine",
        transition_fn = "Self::transition_waiting_masked_comparand_reveal"
    )]
    WaitingMaskedComparandsReveal(states::WaitingMaskedComparandsReveal<T>),

    /// We are waiting for the prefix factor REVEAL.
    #[state_machine(submachine = "state.pub_mult_state_machine", transition_fn = "Self::transition_waiting_pub_mult")]
    WaitingPubMult(states::WaitingPubMult<T>),

    /// We are waiting for the masked filter REVEAL.
    #[state_machine(
        submachine = "state.pub_mult_state_machine",
        transition_fn = "Self::transition_waiting_pub_inner_product"
    )]
    WaitingPubInnerProduct(states::WaitingPubInnerProduct<T>),
}

use CompareState::*;

impl<T> CompareState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new COMPARE state.
    pub fn new(
        comparands: Vec<Comparands<T>>,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), CompareCreateError> {
        let shares = Self::build_masked_comparand_shares(&comparands)?;
        let (reveal_state, messages) = RevealState::new(RevealMode::new_all(shares), secret_sharer.clone())?;
        let prep_elements = comparands.into_iter().map(|comparand| comparand.prep_elements).collect();
        let state = states::WaitingMaskedComparandsReveal {
            reveal_state_machine: StateMachine::new(reveal_state),
            secret_sharer,
            prep_elements,
            comparands: Vec::new(),
        };
        let messages =
            messages.into_iter().map(|message| message.wrap(&CompareStateMessage::MaskedComparandsReveal)).collect();
        Ok((WaitingMaskedComparandsReveal(state), messages))
    }

    fn transition_waiting_masked_comparand_reveal(
        state: states::WaitingMaskedComparandsReveal<T>,
    ) -> StateMachineStateResult<Self> {
        let operands = Self::build_prefix_factor_operands(&state.comparands, &state.prep_elements)?;
        let (pub_mult_state, messages) = PubMultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create PUB-MULT state: {e}"))?;
        let batch_size = T::MODULO
            .bits()
            .checked_sub(1)
            .ok_or_else(|| anyhow!("integer underflow"))?
            .checked_div(2)
            .ok_or_else(|| anyhow!("integer underflow"))?;
        let messages = messages.into_iter().map(|message| message.wrap(&CompareStateMessage::PubMult)).collect();
        let next_state = states::WaitingPubMult {
            pub_mult_state_machine: StateMachine::new(pub_mult_state),
            secret_sharer: state.secret_sharer,
            prep_elements: state.prep_elements,
            batch_size,
            comparands: state.comparands,
            prefix_factors: Batches::default(),
        };
        Ok(StateMachineStateOutput::Messages(WaitingPubMult(next_state), messages))
    }

    fn transition_waiting_pub_mult(state: states::WaitingPubMult<T>) -> StateMachineStateResult<Self> {
        let operands =
            Self::build_masked_filter_operands(&state.comparands, &state.prep_elements, state.prefix_factors)?;
        let (pub_mult_state, messages) = PubMultState::new(operands, state.secret_sharer.clone())
            .map_err(|e| anyhow!("failed to create PUB-MULT state: {e}"))?;
        let messages =
            messages.into_iter().map(|message| message.wrap(&CompareStateMessage::PubInnerProduct)).collect();
        let next_state = states::WaitingPubInnerProduct {
            pub_mult_state_machine: StateMachine::new(pub_mult_state),
            prep_elements: state.prep_elements,
            comparands: state.comparands,
            filters: Vec::new(),
        };
        Ok(StateMachineStateOutput::Messages(WaitingPubInnerProduct(next_state), messages))
    }

    fn transition_waiting_pub_inner_product(state: states::WaitingPubInnerProduct<T>) -> StateMachineStateResult<Self> {
        let comparisons = Self::build_output_shares(state.comparands, state.prep_elements, state.filters)?;
        Ok(StateMachineStateOutput::Final(comparisons))
    }

    fn handle_message(mut state: Self, message: PartyMessage<CompareStateMessage>) -> StateMachineStateResult<Self> {
        use CompareStateMessage::*;
        let (party_id, message) = message.into_parts();
        match (message, &mut state) {
            (MaskedComparandsReveal(message), WaitingMaskedComparandsReveal(inner)) => {
                match inner.reveal_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.comparands = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, CompareStateMessage::MaskedComparandsReveal),
                }
            }
            (PubMult(message), WaitingPubMult(inner)) => {
                match inner.pub_mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        let values = Batches::from_flattened_fixed(values, inner.batch_size)
                            .map_err(|e| anyhow!("batch construction failed: {e}"))?;
                        inner.prefix_factors = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, CompareStateMessage::PubMult),
                }
            }
            (PubInnerProduct(message), WaitingPubInnerProduct(inner)) => {
                match inner.pub_mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(values) => {
                        inner.filters = values;
                        state.try_next()
                    }
                    output => state.wrap_message(output, CompareStateMessage::PubInnerProduct),
                }
            }
            (message, _) => Ok(StateMachineStateOutput::OutOfOrder(state, PartyMessage::new(party_id, message))),
        }
    }

    fn build_masked_comparand_shares(
        comparands: &[Comparands<T>],
    ) -> Result<Vec<ModularNumber<T>>, CompareCreateError> {
        let two = ModularNumber::two();
        let mut shares = Vec::new();
        for comparand in comparands {
            let share = comparand.left - &comparand.right;
            let share = two * &share;
            let share = share + &comparand.prep_elements.quaternary.merge_bits();
            shares.push(share);
        }
        Ok(shares)
    }

    fn build_prefix_factor_operands(
        comparands: &[ModularNumber<T>],
        prep_elements: &[PrepCompareShares<T>],
    ) -> Result<Vec<PubOperandShares<T>>, Error> {
        let one = ModularNumber::ONE;
        let two = ModularNumber::two();
        let mut operands = Vec::new();
        for (comparand, prep_element) in comparands.iter().zip(prep_elements.iter()) {
            let comparand = comparand.into_value();
            let mut quaternary = prep_element.quaternary.shares().iter();
            let _ = quaternary.next().ok_or_else(|| anyhow!("not enough bits"))?;
            for (q, ((rq, prefix_tuple), zero)) in
                quaternary.zip(prep_element.prefix_mult_tuples.iter()).zip(prep_element.zero_shares.iter()).enumerate()
            {
                let q = q.checked_add(1).ok_or_else(|| anyhow!("integer overflow calculating bits"))?;
                let two_q = q.checked_mul(2).ok_or_else(|| anyhow!("integer overflow calculating bits"))?;
                let two_q_plus_1 = two_q.checked_add(1).ok_or_else(|| anyhow!("integer overflow calculating bits"))?;
                let c0 = comparand.bit(two_q);
                let c1 = comparand.bit(two_q_plus_1);
                let (r0, r1, rr) = rq.as_parts();
                let eq = match (c1, c0) {
                    (false, false) => one + r0 + r1 - rr,
                    (false, true) => two - r0 + rr,
                    (true, false) => two - r1 + rr,
                    (true, true) => two - rr,
                };
                let operand = PubOperandShares::single(prefix_tuple.domino, eq, *zero);
                operands.push(operand);
            }
        }
        Ok(operands)
    }

    fn less(index: usize, c: T::Normal, r: &QuaternaryShares<T>) -> Result<ModularNumber<T>, Error> {
        let r_i = r.shares().get(index).ok_or_else(|| anyhow!("not enough elements"))?;
        let two_i = index.checked_mul(2).ok_or_else(|| anyhow!("integer overflow calculating bits"))?;
        let two_i_plus_1 = two_i.checked_add(1).ok_or_else(|| anyhow!("integer overflow calculating bits"))?;
        let c0 = c.bit(two_i);
        let c1 = c.bit(two_i_plus_1);
        let (r0, r1, rr) = r_i.as_parts();
        let lt = match (c1, c0) {
            (false, false) => *r0 + r1 - rr,
            (false, true) => *r1,
            (true, false) => *rr,
            (true, true) => ModularNumber::ZERO,
        };
        Ok(lt)
    }

    fn build_masked_filter_operands(
        comparands: &[ModularNumber<T>],
        prep_elements: &[PrepCompareShares<T>],
        prefix_factors: Batches<ModularNumber<T>>,
    ) -> Result<Vec<PubOperandShares<T>>, Error> {
        let mut operands = Vec::new();
        let zipped = comparands.iter().zip(prep_elements.iter()).zip(prefix_factors.iter());
        for ((comparand, prep_elements), prefix_factors) in zipped {
            let comparand = comparand.into_value();
            // This performs a single backwards loop and computes both the accumulated product output,
            // which becomes part of the prefix product at the end.
            let mut product = ModularNumber::ONE;
            let mut masks = vec![product];
            let bits = T::MODULO
                .bits()
                .checked_sub(1)
                .ok_or_else(|| anyhow!("integer underflow"))?
                .checked_div(2)
                .ok_or_else(|| anyhow!("integer underflow"))?;

            let lt = Self::less(bits, comparand, &prep_elements.quaternary)?;
            let mut lesses = vec![lt];
            // Iterate bits, masks, and prefix factors backwards.
            let zipped =
                (0..bits).rev().zip(prep_elements.prefix_mult_tuples.iter().rev()).zip(prefix_factors.iter().rev());
            for ((bit, tuple), factor) in zipped {
                product = product * factor;
                let mask = tuple.mask * &product;
                masks.push(mask);
                let lt = Self::less(bit, comparand, &prep_elements.quaternary)?;
                lesses.push(lt);
            }
            masks.push(ModularNumber::ONE);
            lesses.push(prep_elements.bitwise);
            let zero = prep_elements.zero_shares.last().ok_or_else(|| anyhow!("no zero elements"))?;
            let operand = PubOperandShares::new(masks, lesses, *zero);
            operands.push(operand);
        }
        Ok(operands)
    }

    fn build_output_shares(
        comparands: Vec<ModularNumber<T>>,
        prep_elements: Vec<PrepCompareShares<T>>,
        filters: Vec<ModularNumber<T>>,
    ) -> Result<Vec<ModularNumber<T>>, Error> {
        let mut outputs = Vec::new();
        let last_bit_index = T::MODULO.bits().checked_sub(1).ok_or_else(|| anyhow!("integer underflow"))?;
        let zipped = prep_elements.into_iter().zip(filters).zip(comparands);
        for ((prep_elements, filter), comparand) in zipped {
            let filter = filter.into_value();
            // w2 = w0 * d_(l-1) + w1 * (1 - d_(l-1))
            let mask = match filter.bit(last_bit_index) {
                true => prep_elements.comparison_least_bit,
                false => prep_elements.comparison_most_bit,
            };
            let c0 = comparand.into_value().bit(0);
            let d0 = filter.bit(0);
            // (c0 ^ d0) ^ mask) by doing: a + [b] - 2a * [b]
            let output = BitShare::from(mask).xor_mask(c0 ^ d0);
            outputs.push(output.into());
        }
        Ok(outputs)
    }
}

/// A message for the COMPARE protocol.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum CompareStateMessage {
    /// A message for the masked comparand REVEAL state machine.
    MaskedComparandsReveal(RevealStateMessage<EncodedModularNumber>) = 0,

    /// A message for the prefix factor PUB-MULT state machine.
    PubMult(PubMultStateMessage) = 1,

    /// A message for the masked filter PUB-MULT state machine.
    PubInnerProduct(PubMultStateMessage) = 2,
}

/// An error during the COMPARE state creation.
#[derive(Debug, thiserror::Error)]
pub enum CompareCreateError {
    /// An error during the REVEAL creation.
    #[error("REVEAL: {0}")]
    Reveal(#[from] PartySecretMismatch),

    /// An arithmetic error.
    #[error("arithmetic: {0}")]
    Arithmetic(#[from] DivByZero),

    /// An bit share error.
    #[error("bit share: {0}")]
    BitShare(#[from] BitShareError),
}

#[allow(clippy::arithmetic_side_effects, clippy::indexing_slicing)]
#[cfg(test)]
mod test {
    use super::*;
    use crate::{
        multiplication::multiplication_unbounded::prefix::PrefixMultTuple, random::random_quaternary::QuatShare,
    };
    use math_lib::modular::U64SafePrime;
    use rstest::rstest;

    type Prime = U64SafePrime;
    type State = CompareState<Prime>;

    fn quat(n: u64, i: u64) -> u64 {
        (n >> (2 * i)) & 3
    }

    fn to_modular(nums: Vec<u64>) -> Vec<ModularNumber<Prime>> {
        nums.into_iter().map(ModularNumber::from_u64).collect()
    }

    fn prefix_tuple(mask: u64, domino: u64) -> PrefixMultTuple<Prime> {
        let mask = ModularNumber::from_u64(mask);
        let domino = ModularNumber::from_u64(domino);
        PrefixMultTuple { mask, domino }
    }

    fn operands(left: u64, right: u64, zero: u64) -> Vec<PubOperandShares<Prime>> {
        let left = ModularNumber::from_u64(left);
        let right = ModularNumber::from_u64(right);
        let zero = ModularNumber::from_u64(zero);
        let o = PubOperandShares::single(left, right, zero);
        vec![o]
    }

    fn quaternary_shares(secret: u64) -> QuaternaryShares<Prime> {
        let mut shares = Vec::new();
        let mut secret = secret;
        for _ in 0..32 {
            let low = ModularNumber::from_u64(secret % 2);
            secret /= 2;
            let high = ModularNumber::from_u64(secret % 2);
            secret /= 2;
            let cross = low * &high;
            let share = QuatShare::new(low, high, cross);
            shares.push(share);
        }
        let secret: QuaternaryShares<Prime> = QuaternaryShares::from(shares);
        secret
    }

    #[rstest]
    #[case(17327877544086937004, 15551573572836973938, 4601119318718832436)]
    #[case(13170101739055978356, 3457953369154714558, 3296022245490799412)]
    #[case(11795222023072750815, 1356280443961305752, 4781271740146903192)]
    #[case(16078619906049547474, 8523453235128868921, 8595175707956406288)]
    #[case(14172841968623296097, 13268353039401921411, 4207116972666039987)]
    #[case(10804756281069449988, 12788807420646641878, 8724309053300119894)]
    #[case(7223225645421231089, 8763783599323834821, 7606077192477806845)]
    #[case(8204933599129402115, 2935041177501161480, 1800311159347993608)]
    #[case(8396186361238186768, 7639729264134829481, 6937758160000897057)]
    #[case(10461060303002325622, 14422398587980896012, 627310189878580789)]
    #[case(16538470546176250998, 313420458644599421, 3898233904453499485)]
    #[case(17831962404372862702, 182022196152364779, 7142357384777033099)]
    #[case(6358291841539871501, 3376349108119000509, 486850524770213309)]
    #[case(17846977297586185474, 13489163602941439040, 6026849795819924673)]
    #[case(7071374814523352020, 9098158519124565510, 8017021948991053798)]
    #[case(1928399336346563938, 338315963876395773, 923509313781258493)]
    #[case(2130096194603498094, 227578871075437675, 552825508769168472)]
    #[case(18121689602169852201, 2530334438571823319, 3619075319188582487)]
    #[case(15324245657829768323, 13183019050708185577, 7044236971274893014)]
    #[case(17632701561921014958, 3878967520247255485, 8060383921088237998)]
    #[case(20, 10, 30)]
    fn masked_comparand(#[case] a: u64, #[case] b: u64, #[case] r: u64) {
        // This is used as a placeholders for all the `PrepCompareShares` attributes we don't need.
        let dummy = ModularNumber::ONE;
        let comparands = &[Comparands {
            left: ModularNumber::from_u64(a),
            right: ModularNumber::from_u64(b),
            prep_elements: PrepCompareShares {
                bitwise: dummy,
                quaternary: quaternary_shares(r),
                comparison_least_bit: dummy,
                comparison_most_bit: dummy,
                prefix_mult_tuples: vec![],
                zero_shares: vec![],
            },
        }];
        let masked_shares = State::build_masked_comparand_shares(comparands).expect("build failed");
        assert_eq!(masked_shares.len(), 1);
        let a = ModularNumber::from_u64(a);
        let b = ModularNumber::from_u64(b);
        let r = ModularNumber::from_u64(r);
        assert_eq!(masked_shares[0], ModularNumber::two() * &(a - &b) + &r);
    }

    #[rstest]
    #[case(17327877544086937004, 15551573572836973938, 13680516355230027293, 4601119318718832436)]
    #[case(13170101739055978356, 3457953369154714558, 12193990567049008949, 3296022245490799412)]
    #[case(11795222023072750815, 1356280443961305752, 5079556084468873624, 4781271740146903192)]
    #[case(16078619906049547474, 8523453235128868921, 7434335662440761492, 8595175707956406288)]
    #[case(14172841968623296097, 13268353039401921411, 12053786239775985329, 4207116972666039987)]
    #[case(10804756281069449988, 12788807420646641878, 8653310975148996878, 8724309053300119894)]
    #[case(7223225645421231089, 8763783599323834821, 2408975740613923065, 7606077192477806845)]
    #[case(8204933599129402115, 2935041177501161480, 11095428513250122798, 1800311159347993608)]
    #[case(8396186361238186768, 7639729264134829481, 6972414463174398547, 6937758160000897057)]
    #[case(10461060303002325622, 14422398587980896012, 906780164723217589, 627310189878580789)]
    #[case(16538470546176250998, 313420458644599421, 3683114454407790169, 3898233904453499485)]
    #[case(17831962404372862702, 182022196152364779, 7142357591472464139, 7142357384777033099)]
    #[case(6358291841539871501, 3376349108119000509, 6287523544712878476, 486850524770213309)]
    #[case(17846977297586185474, 13489163602941439040, 6308364330230246601, 6026849795819924673)]
    #[case(7071374814523352020, 9098158519124565510, 12486944638827470326, 8017021948991053798)]
    #[case(1928399336346563938, 338315963876395773, 4527463229467793651, 923509313781258493)]
    #[case(2130096194603498094, 227578871075437675, 5085733559628192912, 552825508769168472)]
    #[case(18121689602169852201, 2530334438571823319, 12698050726142637108, 3619075319188582487)]
    #[case(15324245657829768323, 13183019050708185577, 7044236971274893014, 8422340384885798888)]
    #[case(17632701561921014958, 3878967520247255485, 8060383921088237998, 1029138018230198)]
    #[case(8, 0, 89, 313132)]
    #[case(6, 6, 89, 95)]
    #[case(123, 1, 43, 12)]
    fn prefix_factors(#[case] c: u64, #[case] r: u64, #[case] d: u64, #[case] z: u64) {
        // This is used as a placeholders for all the `PrepCompareShares` attributes we don't need.
        let dummy = ModularNumber::ONE;
        let comparand = ModularNumber::from_u64(c);
        let prep_elements = PrepCompareShares {
            bitwise: dummy,
            quaternary: quaternary_shares(r),
            comparison_least_bit: dummy,
            comparison_most_bit: dummy,
            prefix_mult_tuples: vec![prefix_tuple(0, d)],
            zero_shares: to_modular(vec![z, 0]),
        };
        let prefix_factors = State::build_prefix_factor_operands(&[comparand], &[prep_elements]).expect("build failed");
        let c1 = quat(c, 1);
        let r1 = quat(r, 1);
        let x = 2 - ((c1 == r1) as u64);
        let expected = operands(d, x, z);
        assert_eq!(prefix_factors, expected);
    }

    #[rstest]
    #[case(1, 1)]
    #[case(2, 3)]
    #[case(6, 7)]
    #[case(8, 8)]
    #[case(2, 7)]
    #[case(7, 2)]
    #[case(15551573572836973938, 4601119318718832436)]
    #[case(3457953369154714558, 3296022245490799412)]
    #[case(1356280443961305752, 4781271740146903192)]
    #[case(8523453235128868921, 8595175707956406288)]
    #[case(13268353039401921411, 4207116972666039987)]
    #[case(12788807420646641878, 8724309053300119894)]
    #[case(8763783599323834821, 7606077192477806845)]
    #[case(2935041177501161480, 1800311159347993608)]
    #[case(7639729264134829481, 6937758160000897057)]
    #[case(14422398587980896012, 627310189878580789)]
    #[case(313420458644599421, 3898233904453499485)]
    #[case(182022196152364779, 7142357384777033099)]
    #[case(3376349108119000509, 486850524770213309)]
    #[case(13489163602941439040, 6026849795819924673)]
    fn less(#[case] c: u64, #[case] r: u64) {
        let d = ModularNumber::<U64SafePrime>::from_u64(c).into_value();
        let q = quaternary_shares(r);
        for i in 0..32 {
            let lt = State::less(i as usize, d, &q).unwrap();
            let expected = ModularNumber::from_u64((quat(c, i) < quat(r, i)) as u64);
            assert_eq!(lt, expected);
        }
    }

    #[rstest]
    #[case(2, 4, 7, 6, 9, 8)]
    #[case(7, 4, 2, 6, 9, 8)]
    #[case(2, 4, 2, 6, 9, 8)]
    #[case(
        6277006698182737435,
        4601119318718832436,
        13170101739055978356,
        3457953369154714558,
        12193990567049008949,
        3296022245490799412
    )]
    #[case(
        13680516355230027293,
        4601119318718832436,
        13170101739055978356,
        3457953369154714558,
        12193990567049008949,
        3296022245490799412
    )]
    #[case(
        5079556084468873624,
        4781271740146903192,
        16078619906049547474,
        8523453235128868921,
        7434335662440761492,
        8595175707956406288
    )]
    #[case(
        12486944638827470326,
        8017021948991053798,
        1928399336346563938,
        338315963876395773,
        4527463229467793651,
        923509313781258493
    )]
    #[case(
        5085733559628192912,
        552825508769168472,
        18121689602169852201,
        2530334438571823319,
        12698050726142637108,
        3619075319188582487
    )]
    #[case(
        7044236971274893014,
        8422340384885798888,
        17632701561921014958,
        3878967520247255485,
        8060383921088237998,
        1029138018230198
    )]
    fn masked_filters(#[case] c: u64, #[case] s: u64, #[case] r: u64, #[case] m: u64, #[case] p: u64, #[case] z: u64) {
        // This is used as a placeholders for all the `PrepCompareShares` attributes we don't need.
        let dummy = ModularNumber::ONE;
        let s = ModularNumber::from_u64(s);
        let comparand = ModularNumber::from_u64(c);
        let mut prefix = vec![prefix_tuple(0, 0); 30];
        prefix.push(prefix_tuple(m, 0));
        let mut zeros = vec![0; 31];
        zeros.push(z);
        let prep_elements = PrepCompareShares {
            bitwise: s,
            quaternary: quaternary_shares(r),
            comparison_least_bit: dummy,
            comparison_most_bit: dummy,
            prefix_mult_tuples: prefix,
            zero_shares: to_modular(zeros),
        };
        let mut factors = vec![0; 30];
        factors.push(p);
        let prefix_factors = Batches::single(to_modular(factors));
        let masked_filters =
            State::build_masked_filter_operands(&[comparand], &[prep_elements], prefix_factors).expect("build failed");
        // Check batch size.
        assert_eq!(masked_filters.len(), 1);
        // Check left operand.
        let m = ModularNumber::from_u64(m);
        let p = ModularNumber::from_u64(p);
        let v0 = m * &p;
        let mut left = vec![dummy, v0];
        for _ in 0..30 {
            left.push(ModularNumber::ZERO);
        }
        left.push(ModularNumber::ONE);
        assert_eq!(masked_filters[0].left, left);
        // Check right operand.
        let mut right = Vec::new();
        for i in 0..32 {
            right.push(ModularNumber::from_u64((quat(c, 31 - i) < quat(r, 31 - i)) as u64));
        }
        right.push(s);
        assert_eq!(masked_filters[0].right, right);
        // Check the correct Zero is used.
        let z = ModularNumber::from_u64(z);
        assert_eq!(masked_filters[0].zero, z);
    }

    #[rstest]
    #[case(17640583440319289146, 8444089388838091410, 1, 0, 0)]
    #[case(17474992118755818128, 4785612137081652591, 1, 1, 0)]
    #[case(3056508022043597117, 11414465346881853064, 1, 1, 0)]
    #[case(11801942090446839221, 17363953619795151877, 0, 0, 0)]
    #[case(2901775690837795509, 5737663896156659213, 0, 0, 0)]
    #[case(17270844591082902980, 5238564941277287497, 1, 0, 1)]
    #[case(11607366895450847094, 15130754644558391146, 1, 1, 1)]
    #[case(13151439608737506425, 11624999071571130876, 0, 1, 1)]
    #[case(12400901026356010837, 9735291843102026931, 0, 0, 0)]
    #[case(123563335305882786, 6277006698182737435, 1, 1, 0)]
    #[case(12337037579007379393, 16698317691785360387, 0, 0, 0)]
    #[case(6080634823316214124, 9828386322300302000, 0, 1, 0)]
    #[case(3137741351994866341, 2509060387201899927, 1, 0, 0)]
    #[case(7290004616582799030, 10990362510026518493, 1, 1, 0)]
    #[case(11354808965421094900, 14974290152030099109, 1, 1, 0)]
    #[case(10651004004042415356, 1009177374329560933, 0, 1, 0)]
    #[case(8414225546458034262, 12888767042754512704, 0, 0, 0)]
    #[case(6581401243312549511, 13612852468886021188, 0, 0, 1)]
    #[case(16962823728815817071, 1158698625228359580, 1, 1, 0)]
    #[case(14648086389701757367, 5672138167818088944, 1, 1, 0)]
    #[test]
    fn output_shares(
        #[case] comparand: u64,
        #[case] filter: u64,
        #[case] w0: u64,
        #[case] w1: u64,
        #[case] expected: u64,
    ) {
        // This is used as a placeholders for all the `PrepCompareShares` attributes we don't need.
        let dummy = ModularNumber::ONE;
        let comparand = ModularNumber::from_u64(comparand);
        let prep_elements = PrepCompareShares {
            bitwise: dummy,
            quaternary: quaternary_shares(0),
            comparison_least_bit: ModularNumber::from_u64(w0),
            comparison_most_bit: ModularNumber::from_u64(w1),
            prefix_mult_tuples: vec![prefix_tuple(0, 0)],
            zero_shares: to_modular(vec![0, 0]),
        };
        let filter = ModularNumber::from_u64(filter);
        let output =
            State::build_output_shares(vec![comparand], vec![prep_elements], vec![filter]).expect("build failed");
        assert_eq!(output.len(), 1);
        assert_eq!(output[0], ModularNumber::from_u64(expected));
    }
}
