//! Public output equality protocol.

use crate::multiplication::multiplication_public_output::{
    state::{PubMultCreateError, PubMultState, PubMultStateMessage},
    PubOperandShares,
};
use basic_types::PartyMessage;
use math_lib::modular::{ModularNumber, SafePrime};
use serde::{Deserialize, Serialize};
use shamir_sharing::{
    party::PartyId,
    secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer},
};
use state_machine::{
    state::StateMachineMessage, StateMachine, StateMachineOutput, StateMachineState, StateMachineStateExt,
    StateMachineStateOutput, StateMachineStateResult,
};
use state_machine_derive::StateMachineState;
use std::sync::Arc;

/// State definitions.
pub mod states {
    use crate::multiplication::multiplication_public_output::PubMultStateMachine;
    use math_lib::modular::{ModularNumber, SafePrime};
    use shamir_sharing::secret_sharer::{SafePrimeSecretSharer, ShamirSecretSharer};

    /// The protocol is waiting for each parties' share of the local product.
    pub struct WaitingPubMult<T>
    where
        T: SafePrime,
        ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
    {
        /// The output of the multiplication, generated by PUB-MULT.
        pub(crate) outputs: Vec<ModularNumber<T>>,

        /// The PUB-MULT state machine.
        pub(crate) pub_mult_state_machine: PubMultStateMachine<T>,
    }
}

/// The input shares of the involved operands.
#[derive(Clone, Debug)]
pub struct PublicOutputEqualityShares<T>
where
    T: SafePrime,
{
    /// Left
    pub left: ModularNumber<T>,

    /// Right
    pub right: ModularNumber<T>,

    /// Prep shares
    pub prep_shares: PrepPublicOutputEqualityShares<T>,
}

impl<T: SafePrime> PublicOutputEqualityShares<T> {
    /// Constructs a new operand shares.
    pub fn new(
        left: ModularNumber<T>,
        right: ModularNumber<T>,
        prep_shares: PrepPublicOutputEqualityShares<T>,
    ) -> Self {
        Self { left, right, prep_shares }
    }
}

/// The state machine for the protocol.
#[derive(StateMachineState)]
#[state_machine(
    recipient_id = "PartyId",
    input_message = "PartyMessage<PublicOutputEqualityStateMessage>",
    output_message = "PublicOutputEqualityStateMessage",
    final_result = "Vec<ModularNumber<T>>",
    handle_message_fn = "Self::handle_message"
)]
pub enum PublicOutputEqualityState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// We are waiting for the shares from each party.
    #[state_machine(submachine = "state.pub_mult_state_machine", transition_fn = "Self::transition_waiting_pub_mult")]
    WaitingPubMult(states::WaitingPubMult<T>),
}

use PublicOutputEqualityState::*;

use crate::conditionals::equality_public_output::offline::output::PrepPublicOutputEqualityShares;

impl<T> PublicOutputEqualityState<T>
where
    T: SafePrime,
    ShamirSecretSharer<T>: SafePrimeSecretSharer<T>,
{
    /// Construct a new public output equality protocol state.
    pub fn new(
        shares: Vec<PublicOutputEqualityShares<T>>,
        secret_sharer: Arc<ShamirSecretSharer<T>>,
    ) -> Result<(Self, Vec<StateMachineMessage<Self>>), PublicOutputEqualityCreateError> {
        // Step 1: Share is multiplied by $[g^{\lambda}]$ and revealed using $F_{PUB-MULT}$.
        let operand_shares = Self::build_operands(shares);
        let (pub_mult_state, messages) = PubMultState::new(operand_shares, secret_sharer)?;
        let next_state =
            states::WaitingPubMult { outputs: Vec::new(), pub_mult_state_machine: StateMachine::new(pub_mult_state) };
        let messages =
            messages.into_iter().map(|message| message.wrap(&PublicOutputEqualityStateMessage::PubMult)).collect();
        Ok((WaitingPubMult(next_state), messages))
    }

    fn build_operands(shares: Vec<PublicOutputEqualityShares<T>>) -> Vec<PubOperandShares<T>> {
        let mut operands: Vec<PubOperandShares<T>> = Vec::new();
        for c in shares {
            let o = PubOperandShares::single(c.left - &c.right, c.prep_shares.ran, c.prep_shares.zero_two_t);
            operands.push(o);
        }
        operands
    }

    fn handle_message(
        mut state: Self,
        message: PartyMessage<PublicOutputEqualityStateMessage>,
    ) -> StateMachineStateResult<Self> {
        use PublicOutputEqualityStateMessage::PubMult;
        let (party_id, message) = message.into_parts();
        match message {
            PubMult(message) => {
                let inner = state.waiting_pub_mult_state_mut()?;
                match inner.pub_mult_state_machine.handle_message(PartyMessage::new(party_id, message))? {
                    StateMachineOutput::Final(output) => {
                        inner.outputs = output;
                        state.try_next()
                    }
                    output => state.wrap_message(output, PubMult),
                }
            }
        }
    }

    fn transition_waiting_pub_mult(state: states::WaitingPubMult<T>) -> StateMachineStateResult<Self> {
        let mut results = Vec::new();
        for output in state.outputs.into_iter() {
            if output == ModularNumber::ZERO {
                results.push(ModularNumber::ONE);
            } else {
                results.push(ModularNumber::ZERO);
            }
        }
        Ok(StateMachineStateOutput::Final(results))
    }
}

/// A message for this state machine.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[repr(u8)]
pub enum PublicOutputEqualityStateMessage {
    /// A message for the underlying PUB-MULT state machine.
    PubMult(PubMultStateMessage) = 0,
}

/// An error during the PUB-MULT state construction.
#[derive(thiserror::Error, Debug)]
pub enum PublicOutputEqualityCreateError {
    /// Pub-Mult creation failed.
    #[error(transparent)]
    PubMultCreateError(#[from] PubMultCreateError),
}
